<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Êô∫ËÉΩÂçïËØçÂ≠¶‰π†Á≥ªÁªü</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans SC', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 20px;
      text-align: center;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 16px;
      opacity: 0.9;
    }

    .content {
      padding: 40px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }

    .stat-card {
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
    }
    
    .stat-card.quick-start {
      cursor: pointer;
      border: 2px dashed #667eea;
      background: #f8fafc;
    }
    
    .stat-card.quick-start:hover {
      background: #f1f5f9;
      border-color: #764ba2;
    }
    
    .stat-card.quick-start .stat-value {
      color: #667eea;
      font-size: 40px;
    }

    .stat-card.blue { background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); }
    .stat-card.red { background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); }
    .stat-card.yellow { background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); }
    .stat-card.green { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); }

    .stat-value {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .stat-card.blue .stat-value { color: #0284c7; }
    .stat-card.red .stat-value { color: #dc2626; }
    .stat-card.yellow .stat-value { color: #d97706; }
    .stat-card.green .stat-value { color: #059669; }

    .stat-label {
      font-size: 14px;
      color: #64748b;
      font-weight: 500;
    }

    .section {
      margin-bottom: 40px;
    }

    .section-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 15px;
      color: #1e293b;
    }

    .section-desc {
      font-size: 14px;
      color: #64748b;
      margin-bottom: 15px;
      line-height: 1.6;
    }

    textarea {
      width: 100%;
      height: 200px;
      padding: 20px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      resize: none;
      transition: border-color 0.3s ease;
    }

    textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      background: #94a3b8;
    }
    
    button:disabled:hover {
      transform: none;
      box-shadow: none;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:disabled {
      background: linear-gradient(135deg, #a3b3f3 0%, #a48cb9 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #475569;
    }

    .btn-secondary:hover {
      background: #cbd5e1;
    }

    .btn-danger {
      background: #fecaca;
      color: #dc2626;
    }

    .mode-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .mode-card {
      padding: 40px;
      border: 3px solid #e2e8f0;
      border-radius: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    }

    .mode-card:hover {
      border-color: #667eea;
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(102, 126, 234, 0.3);
    }

    .mode-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #e2e8f0;
      box-shadow: none;
      transform: none;
    }

    .mode-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }

    .mode-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 10px;
      color: #1e293b;
    }

    .mode-desc {
      font-size: 14px;
      color: #64748b;
    }

    .practice-container {
      max-width: 800px;
      margin: 0 auto;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 10px;
      margin-bottom: 30px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }

    .stats-row {
      display: flex;
      justify-content: space-around;
      background: #f8fafc;
      padding: 25px;
      border-radius: 12px;
      margin-bottom: 30px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item-label {
      font-size: 14px;
      color: #64748b;
      margin-bottom: 8px;
    }

    .stat-item-value {
      font-size: 32px;
      font-weight: 700;
    }

    .stat-item-value.purple { color: #667eea; }
    .stat-item-value.green { color: #10b981; }
    .stat-item-value.red { color: #ef4444; }

    .question-card {
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      padding: 50px 40px;
      border-radius: 15px;
      margin-bottom: 30px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .audio-btn {
      margin: 0 auto 30px;
      padding: 20px 40px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .audio-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
    }

    .prompt-text {
      font-size: 48px;
      font-weight: 700;
      text-align: center;
      color: #1e293b;
      margin-bottom: 30px;
    }

    .feedback {
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .feedback.correct {
      background: #d1fae5;
      color: #059669;
    }

    .feedback.incorrect {
      background: #fee2e2;
      color: #dc2626;
    }

    input[type="text"], input[type="search"] {
      width: 100%;
      padding: 20px;
      font-size: 20px;
      border: 3px solid #e2e8f0;
      border-radius: 12px;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus, input[type="search"]:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    input[type="search"] {
      font-size: 16px;
      padding: 15px 20px;
      margin-bottom: 10px;
    }

    input[type="text"].correct {
      border-color: #10b981;
      background: #f0fdf4;
    }

    input[type="text"].incorrect {
      border-color: #ef4444;
      background: #fef2f2;
    }

    .hint-text {
      text-align: center;
      color: #64748b;
      font-size: 14px;
      margin-top: 15px;
    }

    .complete-container {
      text-align: center;
      padding: 40px 20px;
    }

    .complete-title {
      font-size: 48px;
      font-weight: 700;
      color: #10b981;
      margin-bottom: 40px;
    }

    .complete-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }

    .complete-stat-card {
      background: #f8fafc;
      padding: 40px 20px;
      border-radius: 15px;
    }

    .complete-stat-value {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .complete-stat-value.purple { color: #667eea; }
    .complete-stat-value.green { color: #10b981; }

    .complete-stat-label {
      font-size: 14px;
      color: #64748b;
    }

    .footer {
      text-align: center;
      color: white;
      opacity: 0.8;
      font-size: 12px;
      margin-top: 30px;
    }

    .btn-small {
      flex: 0 0 auto;
      padding: 16px 30px;
    }

    .curve-chart {
      background: #f8fafc;
      padding: 30px;
      border-radius: 15px;
      margin-top: 30px;
    }

    .curve-title {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 20px;
      text-align: center;
    }

    .curve-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      margin-bottom: 10px;
      background: white;
      border-radius: 10px;
      border-left: 4px solid #667eea;
    }

    .curve-word {
      font-weight: 600;
      color: #1e293b;
    }

    .curve-info {
      display: flex;
      gap: 20px;
      font-size: 12px;
      color: #64748b;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #64748b;
    }
    
    .difficulty-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }

    .difficulty-easy { background: #d1fae5; color: #059669; }
    .difficulty-medium { background: #fef3c7; color: #d97706; }
    .difficulty-hard { background: #fee2e2; color: #dc2626; }

    .word-list {
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .word-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: white;
      border-radius: 10px;
      margin-bottom: 10px;
      border: 2px solid #e2e8f0;
      transition: all 0.3s ease;
    }
    
    .word-item.is-due {
      background: #fef2f2;
      border-color: #fecaca;
    }

    .word-item:hover {
      border-color: #667eea;
      background: #f8fafc;
    }
    
    .word-star {
      font-size: 22px;
      cursor: pointer;
      color: #cbd5e1;
      transition: color 0.2s, transform 0.2s;
    }
    
    .word-star.starred {
      color: #f59e0b;
    }
    
    .word-star:hover {
      transform: scale(1.2);
    }
    
    .word-main {
      flex: 1;
      margin: 0 15px;
    }

    .word-english {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 5px;
    }

    .word-chinese {
      font-size: 14px;
      color: #64748b;
    }

    .word-stats {
      display: flex;
      gap: 15px;
      align-items: center;
      font-size: 12px;
      color: #64748b;
    }

    .mode-progress-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .mode-progress-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      background: #e2e8f0;
      color: #1e293b;
    }

    .mode-progress-badge.mastered { background: #d1fae5; color: #047857; }
    .mode-progress-badge.reviewing { background: #fef3c7; color: #b45309; }
    .mode-progress-badge.learning { background: #fee2e2; color: #b91c1c; }
    .mode-progress-badge.new { background: #e0e7ff; color: #4338ca; }
    
    .settings-container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .setting-card {
      padding: 20px;
      border: 3px solid #e2e8f0;
      border-radius: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #f8fafc;
    }
    
    .setting-card:hover {
      background: #f1f5f9;
    }
    
    .setting-card.active {
      border-color: #667eea;
      background: #f0f2fe;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.2);
    }
    
    .setting-card-title {
      font-size: 16px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 5px;
    }
    
    .setting-card-desc {
      font-size: 12px;
      color: #64748b;
    }
    
    .setting-card-count {
      font-size: 20px;
      font-weight: 700;
      color: #667eea;
      margin-top: 10px;
    }
    
    .slider-container {
      background: #f8fafc;
      padding: 30px;
      border-radius: 12px;
      margin-top: 30px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 16px;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 20px;
    }
    
    .slider-value {
      font-size: 24px;
      color: #667eea;
      font-weight: 700;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 5px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      background: #764ba2;
    }
    
    .warning-text {
      color: #d97706;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      margin-top: 15px;
    }
    
    .smart-hint {
      background: #f8fafc;
      padding: 30px;
      border-radius: 15px;
      margin-top: 30px;
      margin-bottom: 30px;
      border-left: 5px solid #667eea;
    }
    
    .smart-hint-title {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 15px;
    }
    
    .smart-hint-text {
      font-size: 16px;
      color: #475569;
      line-height: 1.6;
    }

    @media (max-width: 768px) {
      .content {
        padding: 20px;
      }

      .header h1 {
        font-size: 28px;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }

      .stat-value {
        font-size: 36px;
      }
      
      .stat-card.quick-start .stat-value {
        font-size: 32px;
      }

      .prompt-text {
        font-size: 32px;
      }

      .mode-grid {
        grid-template-columns: 1fr;
      }

      .button-group {
        flex-direction: column;
      }

      button {
        width: 100%;
      }
      
      .settings-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .word-item {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .word-star {
        position: absolute;
        top: 15px;
        right: 15px;
      }
      
      .word-main {
        margin: 0;
        margin-right: 30px;
      }
      
      .word-stats {
        margin-top: 10px;
        gap: 10px;
        flex-wrap: wrap;
      }

      .mode-progress-row {
        width: 100%;
      }

      .mode-progress-badge {
        width: 100%;
        justify-content: center;
      }

      .curve-item {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .curve-info {
        margin-top: 10px;
        gap: 10px;
        flex-wrap: wrap;
      }
    }

  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // ==================== Ê®°ÂºèÈÖçÁΩÆ‰∏é FSRS Êâ©Â±ï ====================
    const MODE_CONFIG = {
      1: { key: 'enToCn', label: 'Ëã±ËØë‰∏≠', successRating: 3, stabilityBonus: 0.08, difficultyBonus: 0.1 },
      2: { key: 'cnToEn', label: '‰∏≠ËØëËã±', successRating: 4, stabilityBonus: 0.18, difficultyBonus: 0.18 },
      3: { key: 'dictation', label: 'Âê¨ÂÜôÊ®°Âºè', successRating: 4, stabilityBonus: 0.35, difficultyBonus: 0.25 }
    };

    const MODE_IDS = Object.keys(MODE_CONFIG);
    const DAY_IN_MS = 24 * 60 * 60 * 1000;

    class FSRS {
      constructor() {
        this.w = [0.4, 0.6, 2.4, 5.8, 4.93, 0.94, 0.86, 0.01, 1.49, 0.14, 0.94, 2.18, 0.05, 0.34, 1.26, 0.29, 2.61];
      }

      initDifficulty(rating) {
        const d = this.w[4] - Math.exp(this.w[5] * (rating - 1)) + 1;
        return this.constrainDifficulty(d);
      }

      initStability(rating) {
        return Math.max(this.w[rating - 1], 0.1);
      }

      nextStability(d, s, r, rating) {
        const hardPenalty = rating === 2 ? this.w[15] : 1;
        const easyBonus = rating === 4 ? this.w[16] : 1;

        const newS = s * (
          Math.exp(this.w[8]) * (11 - d) * Math.pow(s, -this.w[9]) *
          (Math.exp((1 - r) * this.w[10]) - 1) * hardPenalty * easyBonus + 1
        );

        return Math.max(newS, 0.1);
      }

      nextDifficulty(d, rating) {
        const nextD = d - this.w[6] * (rating - 3);
        return this.constrainDifficulty(nextD);
      }

      constrainDifficulty(d) {
        return Math.min(Math.max(d, 1), 10);
      }

      forgettingCurve(elapsedDays, stability) {
        return Math.pow(1 + elapsedDays / (9 * stability), -1);
      }

      nextInterval(stability, requestedRetention = 0.9) {
        const interval = stability * 9 * (1 / requestedRetention - 1);
        return Math.max(1, Math.round(interval));
      }

      createProgress(now = Date.now()) {
        return {
          difficulty: 5,
          stability: 0.1,
          reps: 0,
          lapses: 0,
          last_review: null,
          due: now,
          retrievability: 0,
          state: 'new',
          interval: 0,
          consecutiveCorrect: 0,
          bestStreak: 0,
          totalAttempts: 0,
          correctAttempts: 0,
          accuracy: 0,
          lastRating: null
        };
      }

      normalizeProgress(progress, now = Date.now()) {
        const base = this.createProgress(now);
        const normalized = { ...base, ...(progress || {}) };
        normalized.due = typeof normalized.due === 'number' && !Number.isNaN(normalized.due)
          ? normalized.due
          : now;
        normalized.interval = typeof normalized.interval === 'number' && !Number.isNaN(normalized.interval)
          ? normalized.interval
          : 0;
        normalized.accuracy = normalized.totalAttempts > 0
          ? normalized.correctAttempts / normalized.totalAttempts
          : 0;
        normalized.state = normalized.state || 'new';
        normalized.consecutiveCorrect = normalized.consecutiveCorrect || 0;
        normalized.bestStreak = normalized.bestStreak || 0;
        normalized.reps = normalized.reps || 0;
        normalized.lapses = normalized.lapses || 0;
        return normalized;
      }

      createModeProgressSet(existing = {}, now = Date.now()) {
        const result = {};
        MODE_IDS.forEach(mode => {
          result[mode] = this.normalizeProgress(existing[mode], now);
        });
        return result;
      }

      updateProgress(progress, rating, options = {}) {
        const now = Date.now();
        const base = this.normalizeProgress(progress, now);
        const updated = { ...base };

        if (base.reps === 0) {
          updated.difficulty = this.initDifficulty(rating);
          updated.stability = this.initStability(rating);
          updated.retrievability = 1;
        } else {
          const elapsedDays = base.last_review ? (now - base.last_review) / DAY_IN_MS : 0;
          updated.retrievability = this.forgettingCurve(elapsedDays, base.stability);
          const nextDifficulty = this.nextDifficulty(base.difficulty, rating);
          updated.difficulty = nextDifficulty;
          updated.stability = this.nextStability(
            nextDifficulty,
            base.stability,
            updated.retrievability,
            rating
          );
        }

        updated.reps = base.reps + 1;
        if (rating === 1) {
          updated.lapses = base.lapses + 1;
        }

        if (rating >= 3) {
          updated.consecutiveCorrect = base.consecutiveCorrect + 1;
          updated.correctAttempts = base.correctAttempts + 1;
          if (options.stabilityBonus) {
            updated.stability *= 1 + options.stabilityBonus;
          }
          if (options.difficultyBonus) {
            updated.difficulty = this.constrainDifficulty(updated.difficulty - options.difficultyBonus);
          }
        } else {
          updated.consecutiveCorrect = 0;
          if (options.degradeOnFail) {
            updated.stability = Math.max(updated.stability * 0.6, 0.05);
            updated.difficulty = this.constrainDifficulty(updated.difficulty + 0.5);
          }
        }

        updated.bestStreak = Math.max(base.bestStreak, updated.consecutiveCorrect);
        updated.totalAttempts = base.totalAttempts + 1;
        updated.accuracy = updated.totalAttempts > 0
          ? updated.correctAttempts / updated.totalAttempts
          : 0;

        updated.last_review = now;
        updated.lastRating = rating;

        updated.interval = this.nextInterval(updated.stability);
        updated.due = now + updated.interval * DAY_IN_MS;

        updated.state = this.getProgressState(updated);

        return updated;
      }

      aggregateWord(word) {
        if (!word) return word;
        const now = Date.now();
        const modeProgress = this.createModeProgressSet(word.modeProgress, now);
        const aggregated = { ...word, modeProgress };

        let difficultySum = 0;
        let stabilitySum = 0;
        let retrievabilitySum = 0;
        let repsSum = 0;
        let lapsesSum = 0;
        let lastReview = 0;
        let earliestDue = Infinity;
        let shortestInterval = Infinity;
        let masteredModes = 0;
        let activeModes = 0;
        let strugglingModes = 0;

        MODE_IDS.forEach(mode => {
          const progress = modeProgress[mode];
          difficultySum += progress.difficulty;
          stabilitySum += progress.stability;
          retrievabilitySum += progress.retrievability || 0;
          repsSum += progress.reps;
          lapsesSum += progress.lapses;
          if (progress.last_review) {
            lastReview = Math.max(lastReview, progress.last_review);
          }
          if (typeof progress.due === 'number' && !Number.isNaN(progress.due)) {
            earliestDue = Math.min(earliestDue, progress.due);
          }
          if (typeof progress.interval === 'number' && progress.interval > 0) {
            shortestInterval = Math.min(shortestInterval, progress.interval);
          }
          if (progress.state === 'mastered') {
            masteredModes += 1;
          }
          if (progress.reps > 0) {
            activeModes += 1;
          }
          const attempts = progress.totalAttempts || 0;
          const correct = progress.correctAttempts || 0;
          if (attempts >= 3 && (attempts - correct) / attempts >= 0.4) {
            strugglingModes += 1;
          }
        });

        const modeCount = MODE_IDS.length || 1;
        aggregated.difficulty = difficultySum / modeCount;
        aggregated.stability = stabilitySum / modeCount;
        aggregated.retrievability = retrievabilitySum / modeCount;
        aggregated.reps = repsSum;
        aggregated.lapses = lapsesSum;
        aggregated.last_review = lastReview || null;
        aggregated.due = Number.isFinite(earliestDue) ? earliestDue : now;
        aggregated.interval = Number.isFinite(shortestInterval) ? shortestInterval : 0;
        aggregated.masteredModes = masteredModes;
        aggregated.activeModes = activeModes;

        if (masteredModes >= 2) {
          aggregated.state = 'mastered';
        } else if (activeModes >= 2 && strugglingModes === 0) {
          aggregated.state = 'reviewing';
        } else if (activeModes > 0) {
          aggregated.state = 'learning';
        } else {
          aggregated.state = 'new';
        }

        return aggregated;
      }

      getProgressState(progress) {
        if (!progress || progress.reps === 0) return 'new';
        const accuracy = progress.accuracy || 0;
        if (progress.consecutiveCorrect >= 5 && accuracy >= 0.9 && progress.interval >= 21) {
          return 'mastered';
        }
        if (progress.consecutiveCorrect >= 3 && accuracy >= 0.75) {
          return 'reviewing';
        }
        if (accuracy < 0.6 || progress.lapses >= 2) {
          return 'learning';
        }
        return 'learning';
      }

      getDifficultyLevel(difficulty) {
        if (difficulty <= 3) return 'easy';
        if (difficulty <= 7) return 'medium';
        return 'hard';
      }

      updateWord(word, rating, modeKey, options = {}) {
        if (!modeKey) return this.aggregateWord(word);
        const now = Date.now();
        const working = { ...word };
        working.modeProgress = this.createModeProgressSet(working.modeProgress, now);
        const progress = working.modeProgress[modeKey];
        const updatedProgress = this.updateProgress(progress, rating, options);
        working.modeProgress[modeKey] = updatedProgress;
        return this.aggregateWord(working);
      }
    }

    // ==================== ‰∏ªÂ∫îÁî® ====================
    class VocabularyApp {
      constructor() {
        this.fsrs = new FSRS();
        this.library = [];
        this.dueWords = [];
        this.stage = 'library';
        this.currentMode = 0;
        this.currentIndex = 0;
        this.answer = '';
        this.feedback = null;
        this.isAnswered = false;
        this.stats = { correct: 0, incorrect: 0 };
        this.updatedWords = [];
        this.finalStats = null;
        this.searchTerm = '';
        this.contentContainer = null;
        this.isInitialized = false;
        this.attemptLog = [];
        this.repeatQueue = [];
        this.lastScrollY = 0;
        this.sessionBaseline = {};
        this.sessionResults = {};

        this.handleSearchInput = this.handleSearchInput.bind(this);

        this.practiceSettings = {
          filter: 'due',
          sort: 'smart',
          quantity: 20
        };

        this.loadLibrary();
        this.render();
      }

      loadLibrary() {
        try {
          const stored = localStorage.getItem('wordLibrary_v2');
          if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
              this.library = parsed
                .map(item => this.normalizeWord(item))
                .filter(Boolean);
            }
          }
        } catch (e) {
          console.error('Load error:', e);
          localStorage.removeItem('wordLibrary_v2');
        }
      }

      saveLibrary() {
        try {
          const normalized = this.library.map(word => this.fsrs.aggregateWord(word));
          this.library = normalized;
          localStorage.setItem('wordLibrary_v2', JSON.stringify(normalized));
        } catch (e) {
          console.error('Save error:', e);
          alert('‰øùÂ≠òÂ§±Ë¥•ÔºåÂèØËÉΩÊòØÂ≠òÂÇ®Á©∫Èó¥‰∏çË∂≥ÔºÅ');
        }
      }

      normalizeWord(rawWord) {
        if (!rawWord || !rawWord.english) return null;
        const now = Date.now();
        const english = String(rawWord.english || '').trim();
        if (!english) return null;

        const chineseList = Array.isArray(rawWord.chinese)
          ? rawWord.chinese
          : typeof rawWord.chinese === 'string'
            ? rawWord.chinese.split(/[,Ôºå;Ôºõ„ÄÅ]/)
            : [];
        const sanitizedChinese = chineseList
          .map(item => String(item || '').trim())
          .filter(Boolean);

        let modeProgress;
        if (rawWord.modeProgress) {
          modeProgress = this.fsrs.createModeProgressSet(rawWord.modeProgress, now);
        } else {
          const legacyProgress = this.fsrs.normalizeProgress({
            difficulty: rawWord.difficulty,
            stability: rawWord.stability,
            reps: rawWord.reps,
            lapses: rawWord.lapses,
            last_review: rawWord.last_review,
            due: rawWord.due,
            retrievability: rawWord.retrievability,
            interval: rawWord.interval
          }, now);
          modeProgress = this.fsrs.createModeProgressSet({}, now);
          modeProgress['1'] = legacyProgress;
        }

        const word = {
          english,
          chinese: sanitizedChinese.length ? sanitizedChinese : [''],
          isStarred: !!rawWord.isStarred,
          modeProgress
        };

        return this.fsrs.aggregateWord(word);
      }

      addWords(text) {
        if (!text || !text.trim()) {
          alert('ËØ∑ËæìÂÖ•ÂçïËØçÔºÅ');
          return;
        }

        const lines = text.trim().split('\n');
        const newWords = [];
        const now = Date.now();
        let duplicates = 0;

        lines.forEach(raw => {
          const line = raw.trim();
          if (!line) return;

          const parts = line.split(/\s+/).filter(Boolean);
          if (parts.length < 2) return;

          let splitIndex = -1;
          for (let i = 1; i < parts.length; i++) {
            const token = parts[i];
            const hasChinese = /[\u4e00-\u9fa5]/.test(token);
            const isEnglishLike = /^[a-zA-Z0-9'\/-]+$/.test(token);
            if (hasChinese || !isEnglishLike) {
              splitIndex = i;
              break;
            }
          }

          if (splitIndex === -1) {
            splitIndex = 1;
          }

          const englishParts = parts.slice(0, splitIndex).map(p => p.toLowerCase());
          const chineseParts = parts.slice(splitIndex);

          const english = englishParts.join(' ').replace(/\s+/g, ' ').trim();
          const chineseText = chineseParts.join(' ').trim();
          if (!english || !chineseText || /[\u4e00-\u9fa5]/.test(english)) return;

          const translations = chineseText
            .split(/[,Ôºå;Ôºõ„ÄÅ]/)
            .map(t => t.trim())
            .filter(t => t);

          if (translations.length === 0) return;

          const exists = this.library.find(w => w.english === english);
          if (!exists) {
            const word = {
              english,
              chinese: translations,
              isStarred: false,
              modeProgress: this.fsrs.createModeProgressSet({}, now)
            };
            newWords.push(this.fsrs.aggregateWord(word));
          } else {
            duplicates++;
          }
        });

        if (newWords.length > 0) {
          this.library = [...this.library, ...newWords];
          this.saveLibrary();
          let msg = `ÊàêÂäüÊ∑ªÂä† ${newWords.length} ‰∏™Êñ∞ÂçïËØçÔºÅ`;
          if (duplicates > 0) {
            msg += `\nË∑≥Ëøá ${duplicates} ‰∏™ÈáçÂ§çÂçïËØç„ÄÇ`;
          }
          alert(msg);
          this.render();
        } else {
          alert(duplicates > 0 ? `ÊâÄÊúâÂçïËØçÈÉΩÂ∑≤Â≠òÂú®ÔºÅ` : 'Ê≤°ÊúâÊúâÊïàÁöÑÂçïËØçÊ†ºÂºèÔºÅ');
        }
      }
      
      toggleStar(english) {
        const word = this.library.find(w => w.english === english);
        if (word) {
          word.isStarred = !word.isStarred;
          this.saveLibrary();
          this.render();
        }
      }

      startPractice() {
        if (this.library.length === 0) {
          alert('ËØçÂ∫ì‰∏∫Á©∫ÔºÅËØ∑ÂÖàÊ∑ªÂä†ÂçïËØç„ÄÇ');
          return;
        }

        this.practiceSettings.filter = 'due';
        this.practiceSettings.sort = 'smart';

        this.stage = 'settings';
        this.render();
      }
      
      startQuickPractice(filter) {
        const words = this.getFilteredWords(filter);
        if (words.length === 0) {
          alert(`ÊöÇÊó†${filter === 'new' ? 'Êñ∞' : 'Êî∂ËóèÁöÑ'}ÂçïËØçÔºÅ`);
          return;
        }

        const selected = this.getSortedWords(words, 'smart').slice(0, 20);
        this.launchPracticeFlow(selected);
      }

      startConfiguredPractice() {
        let filtered = this.getFilteredWords(this.practiceSettings.filter);
        if (filtered.length === 0) {
          alert('ÂΩìÂâçÁ≠õÈÄâÊù°‰ª∂‰∏ãÊ≤°ÊúâÂèØÁªÉ‰π†ÁöÑÂçïËØçÔºÅ');
          return;
        }

        let sorted = this.getSortedWords(filtered, this.practiceSettings.sort);

        const selected = sorted.slice(0, this.practiceSettings.quantity);
        this.launchPracticeFlow(selected);
      }

      launchPracticeFlow(words) {
        this.dueWords = Array.isArray(words) ? words : [];
        this.stage = 'mode';
        this.render();
      }

      selectMode(mode) {
        this.currentMode = mode;
        this.currentIndex = 0;
        this.answer = '';
        this.feedback = null;
        this.isAnswered = false;
        this.stats = { correct: 0, incorrect: 0 };
        this.attemptLog = [];
        this.repeatQueue = [];
        this.sessionBaseline = {};
        this.dueWords.forEach(word => {
          this.sessionBaseline[word.english] = word.masteredModes || 0;
        });
        this.updatedWords = JSON.parse(JSON.stringify(this.dueWords));
        this.sessionResults = {};
        this.updatedWords.forEach(word => {
          this.sessionResults[word.english] = word;
        });
        this.stage = 'practice';
        this.render();

        setTimeout(() => {
          if (mode === 1 || mode === 3) {
            this.playAudio();
          }
          const input = document.getElementById('answerInput');
          if (input) input.focus();
        }, 300);
      }

      playAudio() {
        const word = this.updatedWords[this.currentIndex];
        if (!word || !window.speechSynthesis) {
          console.warn('ËØ≠Èü≥ÂäüËÉΩ‰∏çÂèØÁî®');
          return;
        }
        
        try {
          window.speechSynthesis.cancel();
          const utter = new SpeechSynthesisUtterance(word.english);
          utter.lang = 'en-US';
          utter.rate = 0.85;
          utter.pitch = 1.0;
          utter.volume = 1.0;
          
          utter.onerror = (e) => {
            console.error('Speech error:', e);
          };
          
          window.speechSynthesis.speak(utter);
        } catch (e) {
          console.error('Speech error:', e);
        }
      }

      checkAnswer() {
        if (this.isAnswered) {
          this.handleNext();
          return;
        }

        const text = this.answer.trim();
        if (!text) {
          alert('‚ö†Ô∏è ËØ∑ËæìÂÖ•Á≠îÊ°àÔºÅ');
          return;
        }

        const word = this.updatedWords[this.currentIndex];
        let isCorrect = false;
        const modeKey = String(this.currentMode);
        const modeConfig = MODE_CONFIG[this.currentMode] || {
          successRating: 4,
          stabilityBonus: 0,
          difficultyBonus: 0
        };

        if (this.currentMode === 1) {
          isCorrect = word.chinese.some(t => {
            const normalized = text.toLowerCase().replace(/\s+/g, '');
            const target = t.toLowerCase().replace(/\s+/g, '');
            return normalized.includes(target) || target.includes(normalized);
          });
        }
        else if (this.currentMode === 2) {
          const normalized = text.toLowerCase().trim();
          isCorrect = normalized === word.english.toLowerCase();
        }
        else if (this.currentMode === 3) {
          const parts = text.split(/\s+/);
          if (parts.length >= 2) {
            const answerEn = parts[0].toLowerCase().trim();
            const answerCn = parts.slice(1).join(' ').toLowerCase().replace(/\s+/g, '');
            
            const englishCorrect = answerEn === word.english.toLowerCase();
            const chineseCorrect = word.chinese.some(t => {
              const target = t.toLowerCase().replace(/\s+/g, '');
              return answerCn.includes(target) || target.includes(answerCn);
            });
            
            isCorrect = englishCorrect && chineseCorrect;
          }
        }

        if (isCorrect) {
          this.stats.correct += 1;
          this.feedback = { type: 'correct', text: '‚úì Ê≠£Á°ÆÔºÅÂæàÊ£íÔºÅ' };
        } else {
          this.stats.incorrect += 1;
          const correctAns = this.currentMode === 2
            ? word.english
            : this.currentMode === 3
              ? `${word.english} ${word.chinese.join('Ôºå')}`
              : word.chinese.join('Ôºå');
          this.feedback = { type: 'incorrect', text: `‚úó ÈîôËØØÔºÅÊ≠£Á°ÆÁ≠îÊ°àÔºö${correctAns}` };
        }

        const rating = isCorrect ? modeConfig.successRating : 1;
        const updated = this.fsrs.updateWord(word, rating, modeKey, {
          stabilityBonus: isCorrect ? modeConfig.stabilityBonus : 0,
          difficultyBonus: isCorrect ? modeConfig.difficultyBonus : 0,
          degradeOnFail: true
        });
        this.updatedWords[this.currentIndex] = updated;
        this.sessionResults[updated.english] = updated;
        this.attemptLog.push({
          english: word.english,
          mode: this.currentMode,
          correct: isCorrect,
          rating
        });
        if (!isCorrect) {
          const scheduled = this.repeatQueue.find(item => item.english === updated.english);
          if (!scheduled) {
            const repeatCopy = JSON.parse(JSON.stringify(updated));
            repeatCopy._originMode = this.currentMode;
            this.repeatQueue.push(repeatCopy);
          }
        }
        this.isAnswered = true;
        this.render();

        if (isCorrect) {
          setTimeout(() => this.handleNext(), 1200);
        }
      }

      handleNext() {
        if (this.currentIndex + 1 >= this.updatedWords.length) {
          if (this.repeatQueue.length > 0) {
            const repeats = this.repeatQueue.map(word => this.fsrs.aggregateWord(word));
            this.updatedWords = [...this.updatedWords, ...repeats];
            this.repeatQueue = [];
          } else {
            this.completePractice();
            return;
          }
        }

        this.currentIndex += 1;

        this.answer = '';
        this.feedback = null;
        this.isAnswered = false;
        this.render();

        setTimeout(() => {
          if (this.currentMode === 1 || this.currentMode === 3) {
            this.playAudio();
          }
          const input = document.getElementById('answerInput');
          if (input) input.focus();
        }, 100);
      }

      skipQuestion() {
        const word = this.updatedWords[this.currentIndex];
        const modeKey = String(this.currentMode);
        const updated = this.fsrs.updateWord(word, 1, modeKey, {
          degradeOnFail: true
        });
        this.updatedWords[this.currentIndex] = updated;
        this.sessionResults[updated.english] = updated;
        this.stats.incorrect += 1;
        this.attemptLog.push({
          english: word.english,
          mode: this.currentMode,
          correct: false,
          rating: 1
        });
        const scheduled = this.repeatQueue.find(item => item.english === updated.english);
        if (!scheduled) {
          const repeatCopy = JSON.parse(JSON.stringify(updated));
          repeatCopy._originMode = this.currentMode;
          this.repeatQueue.push(repeatCopy);
        }

        const correctAns = this.currentMode === 2
          ? word.english
          : this.currentMode === 3
            ? `${word.english} ${word.chinese.join('Ôºå')}`
            : word.chinese.join('Ôºå');

        this.feedback = { type: 'incorrect', text: `‚úó ÈîôËØØÔºÅÊ≠£Á°ÆÁ≠îÊ°àÔºö${correctAns}` };
        this.isAnswered = true;
        this.render();
      }

      completePractice() {
        const finalResults = Object.values(this.sessionResults);
        this.updatedWords = finalResults;
        this.library = this.library.map(w => {
          const updated = this.sessionResults[w.english];
          return updated ? this.fsrs.aggregateWord(updated) : w;
        });
        this.saveLibrary();

        this.finalStats = {
          ...this.stats,
          totalWords: finalResults.length,
          totalAttempts: this.attemptLog.length,
          accuracy: this.attemptLog.length > 0
            ? Math.round((this.stats.correct / this.attemptLog.length) * 100)
            : 0,
          masteredWords: finalResults.filter(w => (w.masteredModes || 0) >= 2).length,
          newlyMastered: finalResults.filter(w => {
            const baseline = this.sessionBaseline[w.english] || 0;
            return baseline < 2 && (w.masteredModes || 0) >= 2;
          }).length,
          repeatAttempts: Math.max(this.attemptLog.length - finalResults.length, 0)
        };

        this.repeatQueue = [];
        this.stage = 'complete';
        this.render();
      }

      deleteWord(english) {
        if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÂçïËØç„Äå${english}„ÄçÂêóÔºü`)) {
          return;
        }
        
        this.library = this.library.filter(w => w.english !== english);
        this.saveLibrary();
        this.render();
      }

      resetWord(english) {
        if (!confirm(`Á°ÆÂÆöË¶ÅÈáçÁΩÆÂçïËØç„Äå${english}„ÄçÁöÑÂ≠¶‰π†ËøõÂ∫¶ÂêóÔºü`)) {
          return;
        }
        
        const now = Date.now();
        this.library = this.library.map(w => {
          if (w.english === english) {
            const resetWord = {
              ...w,
              isStarred: w.isStarred,
              modeProgress: this.fsrs.createModeProgressSet({}, now)
            };
            return this.fsrs.aggregateWord(resetWord);
          }
          return w;
        });
        this.saveLibrary();
        this.render();
      }

      clearLibrary() {
        if (!confirm('‚ö†Ô∏è Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËØçÂ∫ìÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§çÔºÅ')) {
          return;
        }
        
        if (!confirm('‚ö†Ô∏è‚ö†Ô∏è ÂÜçÊ¨°Á°ÆËÆ§ÔºöÁúüÁöÑË¶ÅÂà†Èô§ÊâÄÊúâÂçïËØçÂêóÔºü')) {
          return;
        }
        
        this.library = [];
        this.saveLibrary();
        this.render();
        alert('‚úì ËØçÂ∫ìÂ∑≤Ê∏ÖÁ©∫');
      }

      getStats() {
        const now = Date.now();
        return {
          total: this.library.length,
          due: this.library.filter(w => w.due <= now).length,
          learning: this.library.filter(w => w.state === 'learning').length,
          mastered: this.library.filter(w => w.state === 'mastered').length,
          new: this.library.filter(w => w.state === 'new').length,
          starred: this.library.filter(w => w.isStarred).length,
        };
      }
      
      getFilteredWords(filter) {
        const now = Date.now();
        switch (filter) {
          case 'due': return this.library.filter(w => w.due <= now);
          case 'new': return this.library.filter(w => w.state === 'new');
          case 'hard': return this.library.filter(w => w.difficulty >= 7);
          case 'starred': return this.library.filter(w => w.isStarred);
          case 'all': default: return [...this.library];
        }
      }

      getSortedWords(words, sort) {
        const now = Date.now();
        let sorted = [...words];
        switch (sort) {
          case 'smart':
            sorted.sort((a, b) => {
              const aR = a.last_review ? this.fsrs.forgettingCurve((now - a.last_review) / (1000 * 60 * 60 * 24), a.stability) : 0;
              const bR = b.last_review ? this.fsrs.forgettingCurve((now - b.last_review) / (1000 * 60 * 60 * 24), b.stability) : 0;
              return aR - bR;
            });
            break;
          case 'random':
            sorted.sort(() => Math.random() - 0.5);
            break;
          case 'newFirst':
            sorted.sort((a, b) => a.reps - b.reps);
            break;
          case 'errorFirst':
            sorted.sort((a, b) => b.lapses - a.lapses);
            break;
          case 'added':
            sorted.sort((a, b) => this.library.indexOf(a) - this.library.indexOf(b));
            break;
        }
        return sorted;
      }
      
      selectFilter(filter) {
        this.practiceSettings.filter = filter;
        this.render();
      }
      
      selectSort(sort) {
        this.practiceSettings.sort = sort;
        this.render();
      }
      
      updateQuantity(value) {
        this.practiceSettings.quantity = parseInt(value, 10);
        this.render();
      }

      exportLibrary() {
        if (this.library.length === 0) {
          alert('ËØçÂ∫ì‰∏∫Á©∫ÔºåÊó†Ê≥ïÂØºÂá∫ÔºÅ');
          return;
        }
        
        const data = JSON.stringify(this.library, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `vocabulary_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      importLibrary() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const imported = JSON.parse(event.target.result);
              if (!Array.isArray(imported)) {
                throw new Error('Invalid format');
              }
              
              let added = 0;
              imported.forEach(word => {
                const normalized = this.normalizeWord(word);
                if (normalized && !this.library.find(w => w.english === normalized.english)) {
                  this.library.push(normalized);
                  added++;
                }
              });
              
              this.saveLibrary();
              alert(`‚úì ÊàêÂäüÂØºÂÖ• ${added} ‰∏™ÂçïËØçÔºÅ`);
              this.render();
            } catch (err) {
              alert('‚ùå ÂØºÂÖ•Â§±Ë¥•ÔºöÊñá‰ª∂Ê†ºÂºèÈîôËØØÔºÅ');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      render(forceFull = false) {
        const app = document.getElementById('app');
        if (!app) return;

        if (this.stage === 'library') {
          this.lastScrollY = window.scrollY;
        } else {
          this.lastScrollY = 0;
        }

        if (!this.isInitialized || forceFull) {
          app.innerHTML = `
            <div class="container">
              <div class="card">
                ${this.renderHeader()}
                <div class="content"></div>
              </div>
              ${this.renderFooter()}
            </div>
          `;
          this.contentContainer = app.querySelector('.content');
          this.isInitialized = true;
        }

        if (this.contentContainer) {
          this.contentContainer.innerHTML = this.renderStage();
        }

        this.attachEventListeners();

        const targetScroll = this.stage === 'library' ? this.lastScrollY : 0;
        window.requestAnimationFrame(() => {
          window.scrollTo(0, targetScroll);
        });
      }

      renderHeader() {
        return `
          <div class="header">
            <h1>üéØ Êô∫ËÉΩÂçïËØçÂ≠¶‰π†Á≥ªÁªü</h1>
            <p>Âü∫‰∫é FSRS ÁÆóÊ≥ïÁöÑÈ´òÊïàËÆ∞ÂøÜÂä©Êâã</p>
          </div>
        `;
      }

      renderFooter() {
        return `
          <div class="footer">
            üí° ÊèêÁ§∫ÔºöÈ¶ñÊ¨°‰ΩøÁî®ËØ∑ÂÖÅËÆ∏ÊµèËßàÂô®ÁöÑËØ≠Èü≥Êí≠ÊîæÊùÉÈôê | FSRS Algorithm v4.5
          </div>
        `;
      }

      renderStage() {
        switch (this.stage) {
          case 'library': return this.renderLibrary();
          case 'settings': return this.renderSettings();
          case 'mode': return this.renderModeSelect();
          case 'practice': return this.renderPractice();
          case 'complete': return this.renderComplete();
          default: return '<div class="loading">Âä†ËΩΩ‰∏≠...</div>';
        }
      }

      renderLibrary() {
        const stats = this.getStats();
        return `
          <div>
            <div class="stats-grid">
              <div class="stat-card blue">
                <div class="stat-value">${stats.total}</div>
                <div class="stat-label">ÊÄªËØçÊ±áÈáè</div>
              </div>
              <div class="stat-card red">
                <div class="stat-value">${stats.due}</div>
                <div class="stat-label">ÂæÖÂ§ç‰π†</div>
              </div>
              <div class="stat-card yellow">
                <div class="stat-value">${stats.learning}</div>
                <div class="stat-label">Â≠¶‰π†‰∏≠</div>
              </div>
              <div class="stat-card green">
                <div class="stat-value">${stats.mastered}</div>
                <div class="stat-label">Â∑≤ÁÜüÁªÉ</div>
              </div>
            </div>

            <div class="section">
              <h2 class="section-title">üöÄ Âø´Êç∑ÂºÄÂßã</h2>
              <div class="stats-grid">
                <div class="stat-card quick-start" id="quickStartNew">
                  <div class="stat-value">üÜï ${stats.new}</div>
                  <div class="stat-label">ÁªÉ‰π†Êñ∞ÂçïËØç</div>
                </div>
                <div class="stat-card quick-start" id="quickStartStarred">
                  <div class="stat-value">‚≠ê ${stats.starred}</div>
                  <div class="stat-label">ÁªÉ‰π†Êî∂Ëóè</div>
                </div>
              </div>
            </div>
            
            <div class="button-group" style="margin-bottom: 40px;">
              <button class="btn-primary" id="startPracticeBtn" ${stats.total === 0 ? 'disabled' : ''}>
                ‚öôÔ∏è ÈÖçÁΩÆÂπ∂ÂºÄÂßãÂ≠¶‰π† (${stats.due})
              </button>
            </div>

            <div class="section">
              <h2 class="section-title">üìù Ê∑ªÂä†Êñ∞ÂçïËØç</h2>
              <p class="section-desc">
                Ê†ºÂºèÔºöËã±ÊñáÂçïËØç ‰∏≠ÊñáÁøªËØëÔºàÂ§ö‰∏™ÁøªËØëÁî®ÈÄóÂè∑ÂàÜÈöîÔºâ<br>
                Á§∫‰æãÔºöapple ËãπÊûú | important ÈáçË¶ÅÁöÑ,ÊúâÈáçË¶ÅÊÑè‰πâÁöÑ
              </p>
              <textarea id="wordInput" placeholder="important ÈáçË¶ÅÁöÑ&#10;cool ÂáâÁàΩ,ÂáâÂø´,ÂæàÈÖ∑ÁöÑ&#10;exact Á≤æÁ°ÆÁöÑ&#10;question È¢òÁõÆ,ÈóÆÈ¢ò&#10;many ÂæàÂ§ö,Â§öÁßç&#10;school Â≠¶Ê†°,Â≠¶Èô¢"></textarea>
              <div class="button-group">
                <button class="btn-primary" id="addWordsBtn">üìö Ê∑ªÂä†Âà∞ËØçÂ∫ì</button>
              </div>
            </div>

            <div class="section">
              <h2 class="section-title">üìö ËØçÂ∫ìÁÆ°ÁêÜ</h2>
              <div class="button-group">
                <button class="btn-secondary" id="exportBtn">üíæ ÂØºÂá∫ËØçÂ∫ì</button>
                <button class="btn-secondary" id="importBtn">üìÇ ÂØºÂÖ•ËØçÂ∫ì</button>
                <button class="btn-danger" id="clearBtn">üóëÔ∏è Ê∏ÖÁ©∫ËØçÂ∫ì</button>
              </div>
            </div>

            ${this.renderWordList()}
          </div>
        `;
      }

      getProgressStateLabel(state) {
        const map = {
          new: 'ÂæÖÂêØÂä®',
          learning: 'Â≠¶‰π†‰∏≠',
          reviewing: 'Â∑©Âõ∫‰∏≠',
          mastered: 'Â∑≤ÁÜüÁªÉ'
        };
        return map[state] || state;
      }

      getWordAverageAccuracy(word) {
        if (!word || !word.modeProgress) return 0;
        const total = MODE_IDS.reduce((sum, mode) => {
          const progress = word.modeProgress[mode];
          return sum + (progress ? progress.accuracy || 0 : 0);
        }, 0);
        return Math.round((total / MODE_IDS.length) * 100);
      }

      renderModeBadges(word) {
        if (!word || !word.modeProgress) return '';
        return `
          <div class="mode-progress-row">
            ${MODE_IDS.map(mode => {
              const progress = word.modeProgress[mode];
              const config = MODE_CONFIG[mode];
              if (!progress || !config) return '';
              const accuracy = Math.round((progress.accuracy || 0) * 100);
              const stateLabel = this.getProgressStateLabel(progress.state);
              return `
                <span class="mode-progress-badge ${progress.state}">
                  ${config.label} ¬∑ ${stateLabel} ¬∑ ${accuracy}%
                </span>
              `;
            }).join('')}
          </div>
        `;
      }

      renderWordList() {
        const now = Date.now();
        const term = this.searchTerm.toLowerCase();
        let displayWords = this.library;

        if (term) {
          displayWords = this.library.filter(w => 
            w.english.toLowerCase().includes(term) || 
            w.chinese.some(c => c.toLowerCase().includes(term))
          );
        }

        if (displayWords.length === 0) {
          return `
            <div id="wordListSection" class="section">
              <h2 class="section-title">üìñ ÂçïËØçÂàóË°®</h2>
              <input type="search" id="searchInput" placeholder="üîç ÊêúÁ¥¢ÂçïËØç..." />
              <div style="text-align: center; padding: 40px; color: #64748b;">
                ${term ? 'Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑÂçïËØç' : 'ËØçÂ∫ì‰∏∫Á©∫ÔºåËØ∑ÂÖàÊ∑ªÂä†ÂçïËØç'}
              </div>
            </div>
          `;
        }

        return `
          <div id="wordListSection" class="section">
            <h2 class="section-title">üìñ ÂçïËØçÂàóË°® (${displayWords.length})</h2>
            <input type="search" id="searchInput" placeholder="üîç ÊêúÁ¥¢ÂçïËØç..." />
            <div class="word-list">
              ${displayWords.map(word => {
                const isDue = word.due <= now;
                const difficultyLevel = this.fsrs.getDifficultyLevel(word.difficulty);
                return `
                  <div class="word-item ${isDue ? 'is-due' : ''}" style="position: relative;">
                    <span class="word-star ${word.isStarred ? 'starred' : ''}" onclick="app.toggleStar('${word.english}')">
                      ${word.isStarred ? '‚≠ê' : '‚òÜ'}
                    </span>
                    <div class="word-main">
                      <div class="word-english">${word.english}</div>
                      <div class="word-chinese">${word.chinese.join('Ôºå')}</div>
                      ${this.renderModeBadges(word)}
                    </div>
                    <div class="word-stats">
                      <span class="difficulty-badge difficulty-${difficultyLevel}">
                        ÈöæÂ∫¶ ${word.difficulty.toFixed(1)}
                      </span>
                      <span>Â§ç‰π† ${word.reps} Ê¨°</span>
                      <span>Èó¥Èöî ${word.interval} Â§©</span>
                      <span>ÊéåÊè°Ê®°Âºè ${word.masteredModes || 0}/${MODE_IDS.length}</span>
                      <span>Âπ≥ÂùáÊ≠£Á°ÆÁéá ${this.getWordAverageAccuracy(word)}%</span>
                      ${isDue ? '<span style="color: #dc2626; font-weight: 600;">ÂæÖÂ§ç‰π†</span>' : ''}
                      <button onclick="app.resetWord('${word.english}')" style="padding: 5px 10px; font-size: 12px; background: #fef3c7; color: #d97706; border: none; border-radius: 5px; cursor: pointer;">ÈáçÁΩÆ</button>
                      <button onclick="app.deleteWord('${word.english}')" style="padding: 5px 10px; font-size: 12px; background: #fee2e2; color: #dc2626; border: none; border-radius: 5px; cursor: pointer;">Âà†Èô§</button>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }

      renderSettings() {
        const counts = {
          due: this.getFilteredWords('due').length,
          all: this.getFilteredWords('all').length,
          new: this.getFilteredWords('new').length,
          hard: this.getFilteredWords('hard').length,
          starred: this.getFilteredWords('starred').length,
        };
        
        const currentFilter = this.practiceSettings.filter;
        const currentSort = this.practiceSettings.sort;
        const currentQuantity = this.practiceSettings.quantity;
        const availableCount = counts[currentFilter];
        const isQuantityInvalid = currentQuantity > availableCount;
        const canStart = availableCount > 0;
        
        return `
          <div class="settings-container">
            <h2 class="section-title">1. Á≠õÈÄâÁªÉ‰π†ÂçïËØç</h2>
            <p class="section-desc">ÈÄâÊã©‰Ω†Êú¨Ê¨°ÊÉ≥ÁªÉ‰π†ÁöÑÂçïËØçËåÉÂõ¥„ÄÇ</p>
            <div class="settings-grid">
              <div class="setting-card ${currentFilter === 'due' ? 'active' : ''}" onclick="app.selectFilter('due')">
                <div class="setting-card-title">üìÖ ÂæÖÂ§ç‰π†</div>
                <div class="setting-card-desc">Âè™ÁªÉÂà∞ÊúüÂçïËØç</div>
                <div class="setting-card-count">${counts.due}</div>
              </div>
              <div class="setting-card ${currentFilter === 'all' ? 'active' : ''}" onclick="app.selectFilter('all')">
                <div class="setting-card-title">üìö ÂÖ®ÈÉ®ÂçïËØç</div>
                <div class="setting-card-desc">ÁªÉ‰π†ÊâÄÊúâÂçïËØç</div>
                <div class="setting-card-count">${counts.all}</div>
              </div>
              <div class="setting-card ${currentFilter === 'new' ? 'active' : ''}" onclick="app.selectFilter('new')">
                <div class="setting-card-title">üÜï Êñ∞ÂçïËØç</div>
                <div class="setting-card-desc">Âè™ÁªÉÊñ∞Ê∑ªÂä†ÁöÑ</div>
                <div class="setting-card-count">${counts.new}</div>
              </div>
              <div class="setting-card ${currentFilter === 'hard' ? 'active' : ''}" onclick="app.selectFilter('hard')">
                <div class="setting-card-title">üî• Âõ∞ÈöæÂçïËØç</div>
                <div class="setting-card-desc">ÈöæÂ∫¶‚â•7ÁöÑÂçïËØç</div>
                <div class="setting-card-count">${counts.hard}</div>
              </div>
              <div class="setting-card ${currentFilter === 'starred' ? 'active' : ''}" onclick="app.selectFilter('starred')">
                <div class="setting-card-title">‚≠ê Êî∂ËóèÂçïËØç</div>
                <div class="setting-card-desc">‰Ω†Êî∂ËóèÁöÑÈáçÁÇπ</div>
                <div class="setting-card-count">${counts.starred}</div>
              </div>
            </div>
            
            <h2 class="section-title">2. Êô∫ËÉΩÊéíÂ∫è</h2>
            <p class="section-desc">ÈÄâÊã©ÂçïËØçÂá∫Áé∞ÁöÑÈ°∫Â∫è„ÄÇ</p>
            <div class="settings-grid">
              <div class="setting-card ${currentSort === 'smart' ? 'active' : ''}" onclick="app.selectSort('smart')">
                <div class="setting-card-title">üß† Êô∫ËÉΩÊé®Ëçê</div>
                <div class="setting-card-desc">FSRSÁÆóÊ≥ïÊéíÂ∫è</div>
              </div>
              <div class="setting-card ${currentSort === 'random' ? 'active' : ''}" onclick="app.selectSort('random')">
                <div class="setting-card-title">üé≤ ÈöèÊú∫È°∫Â∫è</div>
                <div class="setting-card-desc">Êâì‰π±È°∫Â∫è</div>
              </div>
              <div class="setting-card ${currentSort === 'added' ? 'active' : ''}" onclick="app.selectSort('added')">
                <div class="setting-card-title">üìù Ê∑ªÂä†È°∫Â∫è</div>
                <div class="setting-card-desc">ÊåâÊ∑ªÂä†È°∫Â∫è</div>
              </div>
              <div class="setting-card ${currentSort === 'newFirst' ? 'active' : ''}" onclick="app.selectSort('newFirst')">
                <div class="setting-card-title">üå± Êñ∞ËØç‰ºòÂÖà</div>
                <div class="setting-card-desc">Â§ç‰π†Ê¨°Êï∞Â∞ë</div>
              </div>
              <div class="setting-card ${currentSort === 'errorFirst' ? 'active' : ''}" onclick="app.selectSort('errorFirst')">
                <div class="setting-card-title">‚ùå ÈîôËØØ‰ºòÂÖà</div>
                <div class="setting-card-desc">ÈÅóÂøòÊ¨°Êï∞Â§ö</div>
              </div>
            </div>
            
            <div class="slider-container">
              <div class="slider-label">
                <span>3. ÁªÉ‰π†Êï∞Èáè (ÂèØÈÄâ: ${availableCount}‰∏™)</span>
                <span class="slider-value">${currentQuantity}</span>
              </div>
              <input 
                type="range" 
                id="quantitySlider" 
                min="5" 
                max="100" 
                value="${currentQuantity}" 
                step="5"
                ${!canStart ? 'disabled' : ''}
              />
              ${isQuantityInvalid && canStart ? `
                <div class="warning-text">
                  ‚ö†Ô∏è Ë≠¶ÂëäÔºöÊâÄÈÄâÊï∞Èáè (${currentQuantity}) Ë∂ÖÂá∫ÂèØÁî®ÂçïËØçÊï∞ (${availableCount})ÔºåÂ∞ÜÂè™ÁªÉ‰π† ${availableCount} ‰∏™„ÄÇ
                </div>
              ` : ''}
              ${!canStart ? `
                <div class="warning-text">
                  ü§∑‚Äç‚ôÇÔ∏è ÂΩìÂâçÁ≠õÈÄâÊù°‰ª∂‰∏ãÊ≤°ÊúâÂèØÁªÉ‰π†ÁöÑÂçïËØç„ÄÇ
                </div>
              ` : ''}
            </div>

            <div class="button-group">
              <button class="btn-primary" id="startConfiguredPracticeBtn" ${!canStart ? 'disabled' : ''}>
                üöÄ ÂºÄÂßãÁªÉ‰π† (${Math.min(currentQuantity, availableCount)})
              </button>
              <button class="btn-secondary" id="backToLibraryBtn">
                ‚Üê ËøîÂõûËØçÂ∫ì
              </button>
            </div>
          </div>
        `;
      }

      renderModeSelect() {
        return `
          <div>
            <h2 class="section-title" style="text-align: center;">ÈÄâÊã©ÁªÉ‰π†Ê®°Âºè</h2>
            <p class="section-desc" style="text-align: center;">
              Êú¨Ê¨°Â∞ÜÁªÉ‰π† <strong>${this.dueWords.length}</strong> ‰∏™ÂçïËØçÔºåÂçïËØçÈúÄÂú®Ëá≥Â∞ë‰∏§ÁßçÊ®°Âºè‰∏ãËææÊ†áÊâç‰ºöËÆ∞‰∏∫‚ÄúÂ∑≤ÁÜüÁªÉ‚Äù
            </p>

            <div class="mode-grid">
              <div class="mode-card" data-mode="1">
                <div class="mode-icon">üéß</div>
                <div class="mode-title">Ëã±ËØë‰∏≠</div>
                <div class="mode-desc">ÁúãËã±ÊñáÔºåËØ¥Âá∫‰∏≠ÊñáÊÑèÊÄù</div>
              </div>
              
              <div class="mode-card" data-mode="2">
                <div class="mode-icon">‚úçÔ∏è</div>
                <div class="mode-title">‰∏≠ËØëËã±</div>
                <div class="mode-desc">Áúã‰∏≠ÊñáÔºåÊãºÂÜôËã±ÊñáÂçïËØç</div>
              </div>
              
              <div class="mode-card" data-mode="3">
                <div class="mode-icon">üîä</div>
                <div class="mode-title">Âê¨ÂÜôÊ®°Âºè</div>
                <div class="mode-desc">Âê¨ÂèëÈü≥ÔºåÂÜôÂá∫ÂçïËØçÂíåÈáä‰πâ</div>
              </div>
            </div>

            <button class="btn-secondary" id="backToSettingsBtn" style="width: 100%; margin-top: 20px;">
              ‚Üê ËøîÂõûËÆæÁΩÆ
            </button>
          </div>
        `;
      }

      renderPractice() {
        const word = this.updatedWords[this.currentIndex];
        if (!word) {
          return '<div class="loading">Âä†ËΩΩ‰∏≠...</div>';
        }

        const progress = ((this.currentIndex + 1) / this.updatedWords.length) * 100;
        
        let promptText = '';
        let placeholder = '';
        let showAudioBtn = false;
        let showPrompt = true;

        if (this.currentMode === 1) {
          promptText = word.english;
          placeholder = 'ËæìÂÖ•‰∏≠ÊñáÁøªËØë';
          showAudioBtn = true;
        } else if (this.currentMode === 2) {
          promptText = word.chinese.join('Ôºå');
          placeholder = 'ËæìÂÖ•Ëã±ÊñáÂçïËØç';
        } else if (this.currentMode === 3) {
          placeholder = 'Ê†ºÂºèÔºöËã±ÊñáÂçïËØç ‰∏≠ÊñáÁøªËØë';
          showAudioBtn = true;
          showPrompt = false;
        }

        return `
          <div class="practice-container">
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${progress}%"></div>
            </div>

            <div class="stats-row">
              <div class="stat-item">
                <div class="stat-item-label">ËøõÂ∫¶</div>
                <div class="stat-item-value purple">${this.currentIndex + 1}/${this.updatedWords.length}</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-label">Ê≠£Á°Æ</div>
                <div class="stat-item-value green">${this.stats.correct}</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-label">ÈîôËØØ</div>
                <div class="stat-item-value red">${this.stats.incorrect}</div>
              </div>
            </div>

            <div class="question-card">
              ${showAudioBtn ? `
                <button class="audio-btn" id="playAudioBtn">
                  üîä ${this.currentMode === 3 ? 'Êí≠ÊîæÂçïËØç' : 'Êí≠ÊîæÂèëÈü≥'}
                </button>
              ` : ''}
              
              ${showPrompt ? `
                <div class="prompt-text">${promptText}</div>
              ` : `
                <div style="text-align: center; color: #64748b; font-size: 16px; margin: 20px 0;">
                  ÁÇπÂáª‰∏äÊñπÊåâÈíÆÊí≠ÊîæÈü≥È¢ëÔºåÁÑ∂ÂêéËæìÂÖ•Á≠îÊ°à
                </div>
              `}

              ${this.feedback ? `
                <div class="feedback ${this.feedback.type}">
                  ${this.feedback.text}
                </div>
              ` : ''}

              <input
                type="text"
                id="answerInput"
                value="${this.answer}"
                class="${this.feedback ? this.feedback.type : ''}"
                placeholder="${placeholder}"
                ${this.isAnswered ? 'disabled' : ''}
              />
              <div class="hint-text">üí° ËæìÂÖ•ÂÆåÊàêÂêéÊåâÂõûËΩ¶ÈîÆÊèê‰∫§</div>
            </div>

            <div class="button-group">
              <button class="btn-primary" id="checkAnswerBtn">
                ${this.isAnswered ? '‰∏ã‰∏ÄÈ¢ò ‚Üí' : 'Ê£ÄÊü•Á≠îÊ°à'}
              </button>
              ${!this.isAnswered ? `
                <button class="btn-secondary btn-small" id="skipBtn">‰∏ç‰ºö</button>
              ` : ''}
            </div>
            
            <button class="btn-secondary" id="backToModeBtn" style="width: 100%; margin-top: 15px;">
              ‚Üê ËøîÂõûÈÄâÊã©Ê®°Âºè
            </button>
          </div>
        `;
      }

      renderComplete() {
        if (!this.finalStats) {
          return '<div class="loading">Âä†ËΩΩ‰∏≠...</div>';
        }

        return `
          <div class="complete-container">
            <div class="complete-title">üéâ ÁªÉ‰π†ÂÆåÊàêÔºÅ</div>

            <div class="complete-stats">
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.totalAttempts}</div>
                <div class="complete-stat-label">ÊÄª‰ΩúÁ≠îÊ¨°Êï∞</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value green">${this.finalStats.correct}</div>
                <div class="complete-stat-label">Ê≠£Á°ÆÊï∞</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.accuracy}%</div>
                <div class="complete-stat-label">Ê≠£Á°ÆÁéá</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.totalWords}</div>
                <div class="complete-stat-label">Ê∂âÂèäÂçïËØç</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value green">${this.finalStats.masteredWords}</div>
                <div class="complete-stat-label">Â§öÊ®°ÊéåÊè°</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.newlyMastered}</div>
                <div class="complete-stat-label">Êñ∞Â¢ûÁÜüÁªÉ</div>
              </div>
            </div>

            ${this.finalStats.repeatAttempts > 0 ? `
              <div class="smart-hint" style="margin-top: 20px;">
                <div class="smart-hint-title">üîÅ Â∑≤Ëá™Âä®ÂÆâÊéíÈîôÈ¢òÂä†ÁªÉ</div>
                <div class="smart-hint-text">Êú¨Ê¨°Êúâ ${this.finalStats.repeatAttempts} Ê¨°Âõ†ÈîôËØØÈáçÊñ∞ÁªÉ‰π†ÔºåÁ≥ªÁªüÂ∑≤Ëá™Âä®ÂÆâÊéíÂ§ç‰π†ÔºåÈò≤Ê≠¢ÈáçÂ§çÁåúÁ≠îÊ°à„ÄÇ</div>
              </div>
            ` : ''}

            ${this.renderSmartHint()}

            ${this.renderLearningCurve()}

            <div class="button-group">
              <button class="btn-primary" id="continueBtn">üîÑ ËøîÂõûÊ®°ÂºèÈÄâÊã©</button>
              <button class="btn-secondary" id="backToLibraryCompleteBtn">üìö ËøîÂõûËØçÂ∫ì</button>
            </div>
          </div>
        `;
      }
      
      renderSmartHint() {
        const accuracy = this.finalStats.accuracy;
        const attempts = this.finalStats.totalAttempts || 0;
        const dueCount = this.getStats().due;
        let title = 'üí° Êô∫ËÉΩÂª∫ËÆÆ';
        let text = '';

        if (accuracy < 70 && attempts > 0) {
          title = 'ü§î ‰ªçÈúÄÂä™ÂäõÔºÅ';
          text = `Êú¨Ê¨°Ê≠£Á°ÆÁéáÔºà${accuracy}%ÔºâÊúâÁÇπ‰ΩéÂì¶„ÄÇÂà´ÁÅ∞ÂøÉÔºåË¢´Ê†áËÆ∞‰∏∫"ÈîôËØØ"ÁöÑÂçïËØç‰ºöÂæàÂø´ÂÜçÊ¨°Âá∫Áé∞ÔºåÂ§öÁªÉÂá†Ê¨°Â∞±ËÆ∞‰Ωè‰∫ÜÔºÅ`;
        } else if (this.finalStats.newlyMastered > 0) {
          title = 'ü•≥ ÂèàÊéåÊè°‰∫ÜÊñ∞Ê®°ÂºèÔºÅ';
          text = `Êúâ ${this.finalStats.newlyMastered} ‰∏™ÂçïËØçÂú®Ëá≥Â∞ë‰∏§‰∏™Ê®°Âºè‰∏ãËææÊ†áÔºåÁªßÁª≠‰øùÊåÅÂ§öÊ®°ÁªÉ‰π†ÔºåËÆ∞ÂøÜ‰ºöÊõ¥Âä†Áâ¢Âõ∫ÔºÅ`;
        } else if (dueCount > 0) {
          title = 'üëç ÂÅöÂæó‰∏çÈîôÔºÅ';
          text = `‰Ω†ËøòÊúâ <strong>${dueCount}</strong> ‰∏™ÂçïËØçÂæÖÂ§ç‰π†„ÄÇ‰ºëÊÅØ‰∏Ä‰∏ãÔºåÊàñÁÇπÂáª"ËøîÂõûÊ®°ÂºèÈÄâÊã©"ÁªßÁª≠ÊåëÊàòÂêßÔºÅ`;
        } else if (accuracy >= 95) {
          title = 'üéâ Â§™Ê£í‰∫ÜÔºÅ';
          text = '‰Ω†Â∑≤ÂÆåÊàêÊâÄÊúâÂ§ç‰π†ÔºåÂπ∂‰∏î‰øùÊåÅ‰∫ÜÈùûÂ∏∏È´òÁöÑÊ≠£Á°ÆÁéáÔºÅÊòéÂ§©ÂÜçÊù•Â∑©Âõ∫Âêß„ÄÇ';
        } else {
          title = 'üôå ÁªÉ‰π†ÂÆåÊàêÔºÅ';
          text = 'ÊâÄÊúâÂà∞ÊúüÂçïËØçÈÉΩÂ∑≤Â§ç‰π†ÂÆåÊØïÔºÅÂéªËØçÂ∫ìÊ∑ªÂä†‰∏Ä‰∫õÊñ∞ÂçïËØçÔºåÊàñËÄÖ‰ºëÊÅØ‰∏Ä‰∏ãÂêß„ÄÇ';
        }

        return `
          <div class="smart-hint">
            <div class="smart-hint-title">${title}</div>
            <div class="smart-hint-text">${text}</div>
          </div>
        `;
      }

      renderLearningCurve() {
        const words = Object.values(this.sessionResults || {})
          .sort((a, b) => {
            if ((b.masteredModes || 0) !== (a.masteredModes || 0)) {
              return (b.masteredModes || 0) - (a.masteredModes || 0);
            }
            return (b.reps || 0) - (a.reps || 0);
          })
          .slice(0, 10);

        return `
          <div class="curve-chart">
            <div class="curve-title">üìä Êú¨Ê¨°Â≠¶‰π†ËÆ∞ÂΩï (ÈÉ®ÂàÜ)</div>
            ${words.length === 0 ? `
              <div style="padding: 10px 0; color: #64748b;">ÊöÇÊó†ÁªÉ‰π†ËÆ∞ÂΩï</div>
            ` : ''}
            ${words.map(word => {
              const difficultyLevel = this.fsrs.getDifficultyLevel(word.difficulty);
              return `
                <div class="curve-item">
                  <span class="curve-word">${word.english}</span>
                  <div class="curve-info">
                    <span class="difficulty-badge difficulty-${difficultyLevel}">
                      ÈöæÂ∫¶ ${word.difficulty.toFixed(1)}
                    </span>
                    <span>Á®≥ÂÆöÊÄß: ${word.stability.toFixed(1)}Â§©</span>
                    <span>Èó¥Èöî: ${word.interval}Â§©</span>
                    <span>Â§ç‰π†: ${word.reps}Ê¨°</span>
                    <span>ÊéåÊè°Ê®°Âºè: ${word.masteredModes || 0}/${MODE_IDS.length}</span>
                  </div>
                  ${this.renderModeBadges(word)}
                </div>
              `;
            }).join('')}
          </div>
        `;
      }

      attachEventListeners() {
        this.bindEvent('addWordsBtn', 'click', () => {
          const input = document.getElementById('wordInput');
          this.addWords(input.value);
        });

        this.bindEvent('startPracticeBtn', 'click', () => this.startPractice());
        this.bindEvent('quickStartNew', 'click', () => this.startQuickPractice('new'));
        this.bindEvent('quickStartStarred', 'click', () => this.startQuickPractice('starred'));
        this.bindEvent('exportBtn', 'click', () => this.exportLibrary());
        this.bindEvent('importBtn', 'click', () => this.importLibrary());
        this.bindEvent('clearBtn', 'click', () => this.clearLibrary());

        this.setupSearchInput();
        
        this.bindEvent('startConfiguredPracticeBtn', 'click', () => this.startConfiguredPractice());
        this.bindEvent('backToLibraryBtn', 'click', () => {
          this.stage = 'library';
          this.render();
        });
        this.bindEvent('quantitySlider', 'input', (e) => this.updateQuantity(e.target.value));

        document.querySelectorAll('.mode-card').forEach(card => {
          card.onclick = () => this.selectMode(parseInt(card.dataset.mode));
        });
        
        this.bindEvent('backToSettingsBtn', 'click', () => {
          this.stage = 'settings';
          this.render();
        });

        const answerInput = document.getElementById('answerInput');
        if (answerInput) {
          answerInput.oninput = (e) => {
            this.answer = e.target.value;
          };
          answerInput.onkeydown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              this.checkAnswer();
            }
          };
        }

        this.bindEvent('playAudioBtn', 'click', () => this.playAudio());
        this.bindEvent('checkAnswerBtn', 'click', () => this.checkAnswer());
        this.bindEvent('skipBtn', 'click', () => this.skipQuestion());
        this.bindEvent('backToModeBtn', 'click', () => {
          if (confirm('Á°ÆÂÆöË¶ÅÈÄÄÂá∫ÂΩìÂâçÁªÉ‰π†ÂêóÔºüËøõÂ∫¶Â∞Ü‰∏ç‰ºö‰øùÂ≠ò„ÄÇ')) {
            this.stage = 'mode';
            this.render();
          }
        });

        this.bindEvent('continueBtn', 'click', () => {
          this.refreshSelectedWordsFromLibrary();
          this.stage = 'mode';
          this.render();
        });
        this.bindEvent('backToLibraryCompleteBtn', 'click', () => {
          this.stage = 'library';
          this.render();
        });
      }

      setupSearchInput(shouldFocus = false) {
        const searchInput = document.getElementById('searchInput');
        if (!searchInput) return;

        searchInput.value = this.searchTerm;
        searchInput.oninput = this.handleSearchInput;

        if (shouldFocus) {
          const length = searchInput.value.length;
          searchInput.focus();
          searchInput.setSelectionRange(length, length);
        }
      }

      handleSearchInput(event) {
        this.updateSearchTerm(event.target.value);
      }

      updateSearchTerm(value) {
        this.searchTerm = (value || '').toLowerCase();
        this.refreshWordList();
      }

      refreshWordList() {
        if (this.stage !== 'library') return;

        const section = document.getElementById('wordListSection');
        if (!section) return;

        const list = section.querySelector('.word-list');
        const scrollTop = list ? list.scrollTop : 0;

        section.outerHTML = this.renderWordList();
        const newSection = document.getElementById('wordListSection');
        this.setupSearchInput(true);

        if (newSection) {
          const newList = newSection.querySelector('.word-list');
          if (newList) {
            newList.scrollTop = scrollTop;
          }
        }
      }

      refreshSelectedWordsFromLibrary() {
        if (!Array.isArray(this.dueWords) || this.dueWords.length === 0) return;
        this.dueWords = this.dueWords.map(word => {
          const latest = this.library.find(item => item.english === word.english);
          return latest || word;
        });
      }

      bindEvent(id, eventType, handler) {
        const element = document.getElementById(id);
        if (element) {
          element['on' + eventType] = handler;
        }
      }
    }

    let app;
    window.addEventListener('DOMContentLoaded', () => {
      app = new VocabularyApp();
      window.app = app;
    });
  </script>
</body>
</html>