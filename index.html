<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>智能单词学习系统</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans SC', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 20px;
      text-align: center;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 16px;
      opacity: 0.9;
    }

    .content {
      padding: 40px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }

    .stat-card {
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
    }
    
    .stat-card.quick-start {
      cursor: pointer;
      border: 2px dashed #667eea;
      background: #f8fafc;
    }
    
    .stat-card.quick-start:hover {
      background: #f1f5f9;
      border-color: #764ba2;
    }
    
    .stat-card.quick-start .stat-value {
      color: #667eea;
      font-size: 40px;
    }

    .stat-card.blue { background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); }
    .stat-card.red { background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); }
    .stat-card.yellow { background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); }
    .stat-card.green { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); }

    .stat-value {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .stat-card.blue .stat-value { color: #0284c7; }
    .stat-card.red .stat-value { color: #dc2626; }
    .stat-card.yellow .stat-value { color: #d97706; }
    .stat-card.green .stat-value { color: #059669; }

    .stat-label {
      font-size: 14px;
      color: #64748b;
      font-weight: 500;
    }

    .section {
      margin-bottom: 40px;
    }

    .section-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 15px;
      color: #1e293b;
    }

    .section-desc {
      font-size: 14px;
      color: #64748b;
      margin-bottom: 15px;
      line-height: 1.6;
    }

    textarea {
      width: 100%;
      height: 200px;
      padding: 20px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      resize: none;
      transition: border-color 0.3s ease;
    }

    textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      background: #94a3b8;
    }
    
    button:disabled:hover {
      transform: none;
      box-shadow: none;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:disabled {
      background: linear-gradient(135deg, #a3b3f3 0%, #a48cb9 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }

    .btn-secondary {
      background: #e2e8f0;
      color: #475569;
    }

    .btn-secondary:hover {
      background: #cbd5e1;
    }

    .btn-danger {
      background: #fecaca;
      color: #dc2626;
    }

    .mode-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .mode-card {
      padding: 40px;
      border: 3px solid #e2e8f0;
      border-radius: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    }

    .mode-card:hover {
      border-color: #667eea;
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(102, 126, 234, 0.3);
    }

    .mode-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #e2e8f0;
      box-shadow: none;
      transform: none;
    }

    .mode-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }

    .mode-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 10px;
      color: #1e293b;
    }

    .mode-desc {
      font-size: 14px;
      color: #64748b;
    }

    .practice-container {
      max-width: 800px;
      margin: 0 auto;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 10px;
      margin-bottom: 30px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }

    .stats-row {
      display: flex;
      justify-content: space-around;
      background: #f8fafc;
      padding: 25px;
      border-radius: 12px;
      margin-bottom: 30px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item-label {
      font-size: 14px;
      color: #64748b;
      margin-bottom: 8px;
    }

    .stat-item-value {
      font-size: 32px;
      font-weight: 700;
    }

    .stat-item-value.purple { color: #667eea; }
    .stat-item-value.green { color: #10b981; }
    .stat-item-value.red { color: #ef4444; }

    .question-card {
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      padding: 50px 40px;
      border-radius: 15px;
      margin-bottom: 30px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .audio-btn {
      margin: 0 auto 30px;
      padding: 20px 40px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .audio-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
    }

    .prompt-text {
      font-size: 48px;
      font-weight: 700;
      text-align: center;
      color: #1e293b;
      margin-bottom: 30px;
    }

    .feedback {
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .feedback.correct {
      background: #d1fae5;
      color: #059669;
    }

    .feedback.incorrect {
      background: #fee2e2;
      color: #dc2626;
    }

    input[type="text"], input[type="search"] {
      width: 100%;
      padding: 20px;
      font-size: 20px;
      border: 3px solid #e2e8f0;
      border-radius: 12px;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus, input[type="search"]:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    input[type="search"] {
      font-size: 16px;
      padding: 15px 20px;
      margin-bottom: 10px;
    }

    input[type="text"].correct {
      border-color: #10b981;
      background: #f0fdf4;
    }

    input[type="text"].incorrect {
      border-color: #ef4444;
      background: #fef2f2;
    }

    .hint-text {
      text-align: center;
      color: #64748b;
      font-size: 14px;
      margin-top: 15px;
    }

    .complete-container {
      text-align: center;
      padding: 40px 20px;
    }

    .complete-title {
      font-size: 48px;
      font-weight: 700;
      color: #10b981;
      margin-bottom: 40px;
    }

    .complete-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }

    .complete-stat-card {
      background: #f8fafc;
      padding: 40px 20px;
      border-radius: 15px;
    }

    .complete-stat-value {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .complete-stat-value.purple { color: #667eea; }
    .complete-stat-value.green { color: #10b981; }

    .complete-stat-label {
      font-size: 14px;
      color: #64748b;
    }

    .footer {
      text-align: center;
      color: white;
      opacity: 0.8;
      font-size: 12px;
      margin-top: 30px;
    }

    .btn-small {
      flex: 0 0 auto;
      padding: 16px 30px;
    }

    .curve-chart {
      background: #f8fafc;
      padding: 30px;
      border-radius: 15px;
      margin-top: 30px;
    }

    .curve-title {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 20px;
      text-align: center;
    }

    .curve-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      margin-bottom: 10px;
      background: white;
      border-radius: 10px;
      border-left: 4px solid #667eea;
    }

    .curve-word {
      font-weight: 600;
      color: #1e293b;
    }

    .curve-info {
      display: flex;
      gap: 20px;
      font-size: 12px;
      color: #64748b;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #64748b;
    }
    
    .difficulty-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }

    .difficulty-easy { background: #d1fae5; color: #059669; }
    .difficulty-medium { background: #fef3c7; color: #d97706; }
    .difficulty-hard { background: #fee2e2; color: #dc2626; }

    .word-list {
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .word-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: white;
      border-radius: 10px;
      margin-bottom: 10px;
      border: 2px solid #e2e8f0;
      transition: all 0.3s ease;
    }
    
    .word-item.is-due {
      background: #fef2f2;
      border-color: #fecaca;
    }

    .word-item:hover {
      border-color: #667eea;
      background: #f8fafc;
    }
    
    .word-star {
      font-size: 22px;
      cursor: pointer;
      color: #cbd5e1;
      transition: color 0.2s, transform 0.2s;
    }
    
    .word-star.starred {
      color: #f59e0b;
    }
    
    .word-star:hover {
      transform: scale(1.2);
    }
    
    .word-main {
      flex: 1;
      margin: 0 15px;
    }

    .word-english {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 5px;
    }

    .word-chinese {
      font-size: 14px;
      color: #64748b;
    }

    .word-stats {
      display: flex;
      gap: 15px;
      align-items: center;
      font-size: 12px;
      color: #64748b;
    }

    .mode-progress-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .mode-progress-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      background: #e2e8f0;
      color: #1e293b;
    }

    .mode-progress-badge.mastered { background: #d1fae5; color: #047857; }
    .mode-progress-badge.reviewing { background: #fef3c7; color: #b45309; }
    .mode-progress-badge.learning { background: #fee2e2; color: #b91c1c; }
    .mode-progress-badge.new { background: #e0e7ff; color: #4338ca; }
    
    .settings-container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .setting-card {
      padding: 20px;
      border: 3px solid #e2e8f0;
      border-radius: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #f8fafc;
    }
    
    .setting-card:hover {
      background: #f1f5f9;
    }
    
    .setting-card.active {
      border-color: #667eea;
      background: #f0f2fe;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.2);
    }
    
    .setting-card-title {
      font-size: 16px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 5px;
    }
    
    .setting-card-desc {
      font-size: 12px;
      color: #64748b;
    }
    
    .setting-card-count {
      font-size: 20px;
      font-weight: 700;
      color: #667eea;
      margin-top: 10px;
    }
    
    .slider-container {
      background: #f8fafc;
      padding: 30px;
      border-radius: 12px;
      margin-top: 30px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 16px;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 20px;
    }
    
    .slider-value {
      font-size: 24px;
      color: #667eea;
      font-weight: 700;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 5px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      background: #764ba2;
    }
    
    .warning-text {
      color: #d97706;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      margin-top: 15px;
    }
    
    .smart-hint {
      background: #f8fafc;
      padding: 30px;
      border-radius: 15px;
      margin-top: 30px;
      margin-bottom: 30px;
      border-left: 5px solid #667eea;
    }
    
    .smart-hint-title {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 15px;
    }
    
    .smart-hint-text {
      font-size: 16px;
      color: #475569;
      line-height: 1.6;
    }

    /* 移动端专属样式 */
    @media (max-width: 768px) {
      body {
        padding: 0;
        background: white;
        overflow-x: hidden;
      }
      
      body.mobile-practice {
        overflow: hidden;
        height: 100vh;
        position: fixed;
        width: 100%;
      }
      
      body.mobile-mode-select,
      body.mobile-settings,
      body.mobile-complete {
        overflow: hidden;
        height: 100vh;
        position: fixed;
        width: 100%;
      }

      .container {
        max-width: 100%;
        height: 100vh;
      }

      .card {
        border-radius: 0;
        box-shadow: none;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        padding: 15px;
        border-radius: 0;
        flex-shrink: 0;
      }

      .header h1 {
        font-size: 20px;
        margin-bottom: 3px;
      }

      .header p {
        font-size: 12px;
      }

      .content {
        padding: 12px;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      .content.practice-content,
      .content.mode-content,
      .content.settings-content,
      .content.complete-content {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 15px;
      }

      .stat-card {
        padding: 15px 10px;
        border-radius: 10px;
      }

      .stat-value {
        font-size: 28px;
      }
      
      .stat-card.quick-start .stat-value {
        font-size: 24px;
      }

      .stat-label {
        font-size: 12px;
      }

      .section {
        margin-bottom: 20px;
      }

      .section-title {
        font-size: 18px;
        margin-bottom: 10px;
      }

      .section-desc {
        font-size: 12px;
        margin-bottom: 10px;
        line-height: 1.5;
      }

      textarea {
        height: 120px;
        padding: 12px;
        font-size: 13px;
      }

      .button-group {
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
      }

      button {
        width: 100%;
        padding: 12px 18px;
        font-size: 14px;
      }

      .mode-grid {
        grid-template-columns: 1fr;
        gap: 12px;
        margin-bottom: 12px;
      }

      .mode-card {
        padding: 20px;
      }

      .mode-icon {
        font-size: 40px;
        margin-bottom: 10px;
      }

      .mode-title {
        font-size: 16px;
        margin-bottom: 6px;
      }

      .mode-desc {
        font-size: 12px;
      }

      .settings-container {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .settings-container > h2:first-child {
        margin-top: 0;
      }
      
      .settings-scroll-area {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        margin-bottom: 10px;
      }
      
      .settings-buttons {
        flex-shrink: 0;
      }

      .settings-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .setting-card {
        padding: 12px 8px;
      }

      .setting-card-title {
        font-size: 13px;
        margin-bottom: 3px;
      }

      .setting-card-desc {
        font-size: 10px;
      }

      .setting-card-count {
        font-size: 16px;
        margin-top: 6px;
      }

      .slider-container {
        padding: 15px 12px;
        margin-top: 15px;
      }

      .slider-label {
        font-size: 13px;
        margin-bottom: 12px;
      }

      .slider-value {
        font-size: 18px;
      }

      .warning-text {
        font-size: 12px;
        margin-top: 10px;
      }

      .word-list {
        max-height: none;
      }

      .word-item {
        flex-direction: column;
        align-items: flex-start;
        padding: 10px;
        margin-bottom: 8px;
        position: relative;
      }

      .word-star {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 18px;
      }

      .word-main {
        margin: 0;
        margin-right: 30px;
        width: calc(100% - 30px);
      }

      .word-english {
        font-size: 15px;
        margin-bottom: 3px;
      }

      .word-chinese {
        font-size: 12px;
      }

      .word-stats {
        margin-top: 8px;
        gap: 6px;
        flex-wrap: wrap;
        width: 100%;
      }

      .word-stats span {
        font-size: 10px;
      }

      .word-stats button {
        padding: 3px 6px;
        font-size: 10px;
        width: auto;
      }

      .mode-progress-row {
        width: 100%;
        margin-top: 6px;
      }

      .mode-progress-badge {
        width: 100%;
        justify-content: center;
        font-size: 10px;
        padding: 2px 8px;
      }

      .difficulty-badge {
        font-size: 10px;
        padding: 2px 8px;
      }

      /* 移动端练习界面 */
      .practice-container {
        max-width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .progress-bar {
        height: 5px;
        margin-bottom: 10px;
        flex-shrink: 0;
      }

      .stats-row {
        padding: 12px;
        margin-bottom: 10px;
        border-radius: 8px;
        flex-shrink: 0;
      }

      .stat-item-label {
        font-size: 11px;
        margin-bottom: 4px;
      }

      .stat-item-value {
        font-size: 20px;
      }

      .question-card {
        padding: 15px 12px;
        margin-bottom: 10px;
        min-height: 0;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        border-radius: 10px;
      }

      .audio-btn {
        padding: 12px 24px;
        margin: 0 auto 15px;
        font-size: 15px;
        gap: 6px;
      }

      .prompt-text {
        font-size: 24px;
        margin-bottom: 15px;
      }

      .feedback {
        padding: 12px;
        font-size: 14px;
        margin-bottom: 12px;
        border-radius: 8px;
      }

      input[type="text"], input[type="search"] {
        padding: 12px;
        font-size: 15px;
        border-radius: 8px;
      }

      input[type="search"] {
        padding: 10px 12px;
        font-size: 14px;
      }

      .hint-text {
        font-size: 11px;
        margin-top: 10px;
      }

      .practice-container .button-group {
        margin-top: auto;
        flex-shrink: 0;
        gap: 8px;
      }

      /* 移动端完成界面 */
      .complete-container {
        padding: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .complete-scroll-area {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 12px;
      }
      
      .complete-buttons {
        flex-shrink: 0;
        padding: 12px;
        background: white;
        border-top: 1px solid #e2e8f0;
      }

      .complete-title {
        font-size: 28px;
        margin-bottom: 15px;
      }

      .complete-stats {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 15px;
      }

      .complete-stat-card {
        padding: 18px 12px;
        border-radius: 10px;
      }

      .complete-stat-value {
        font-size: 28px;
        margin-bottom: 6px;
      }

      .complete-stat-label {
        font-size: 11px;
      }

      .curve-chart {
        padding: 15px 12px;
        margin-top: 15px;
        border-radius: 10px;
      }

      .curve-title {
        font-size: 15px;
        margin-bottom: 12px;
      }

      .curve-item {
        flex-direction: column;
        align-items: flex-start;
        padding: 10px;
        margin-bottom: 6px;
        border-radius: 8px;
      }

      .curve-word {
        font-size: 14px;
      }

      .curve-info {
        margin-top: 6px;
        gap: 6px;
        flex-wrap: wrap;
        font-size: 10px;
      }

      .smart-hint {
        padding: 15px 12px;
        margin-top: 15px;
        margin-bottom: 15px;
        border-radius: 10px;
        border-left-width: 4px;
      }

      .smart-hint-title {
        font-size: 15px;
        margin-bottom: 10px;
      }

      .smart-hint-text {
        font-size: 13px;
        line-height: 1.5;
      }

      .footer {
        display: none;
      }

      .btn-small {
        padding: 12px 18px;
      }
    }

    

  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // ==================== 模式配置与 FSRS 扩展 ====================
    const MODE_CONFIG = {
      1: { key: 'enToCn', label: '英译中', successRating: 3, stabilityBonus: 0.08, difficultyBonus: 0.1 },
      2: { key: 'cnToEn', label: '中译英', successRating: 4, stabilityBonus: 0.18, difficultyBonus: 0.18 },
      3: { key: 'dictation', label: '听写模式', successRating: 4, stabilityBonus: 0.35, difficultyBonus: 0.25 }
    };

    const MODE_IDS = Object.keys(MODE_CONFIG);
    const DAY_IN_MS = 24 * 60 * 60 * 1000;

    class FSRS {
      constructor() {
        this.w = [0.4, 0.6, 2.4, 5.8, 4.93, 0.94, 0.86, 0.01, 1.49, 0.14, 0.94, 2.18, 0.05, 0.34, 1.26, 0.29, 2.61];
      }

      initDifficulty(rating) {
        const d = this.w[4] - Math.exp(this.w[5] * (rating - 1)) + 1;
        return this.constrainDifficulty(d);
      }

      initStability(rating) {
        return Math.max(this.w[rating - 1], 0.1);
      }

      nextStability(d, s, r, rating) {
        const hardPenalty = rating === 2 ? this.w[15] : 1;
        const easyBonus = rating === 4 ? this.w[16] : 1;

        const newS = s * (
          Math.exp(this.w[8]) * (11 - d) * Math.pow(s, -this.w[9]) *
          (Math.exp((1 - r) * this.w[10]) - 1) * hardPenalty * easyBonus + 1
        );

        return Math.max(newS, 0.1);
      }

      nextDifficulty(d, rating) {
        const nextD = d - this.w[6] * (rating - 3);
        return this.constrainDifficulty(nextD);
      }

      constrainDifficulty(d) {
        return Math.min(Math.max(d, 1), 10);
      }

      forgettingCurve(elapsedDays, stability) {
        return Math.pow(1 + elapsedDays / (9 * stability), -1);
      }

      nextInterval(stability, requestedRetention = 0.9) {
        const interval = stability * 9 * (1 / requestedRetention - 1);
        return Math.max(1, Math.round(interval));
      }

      createProgress(now = Date.now()) {
        return {
          difficulty: 5,
          stability: 0.1,
          reps: 0,
          lapses: 0,
          last_review: null,
          due: now,
          retrievability: 0,
          state: 'new',
          interval: 0,
          consecutiveCorrect: 0,
          bestStreak: 0,
          totalAttempts: 0,
          correctAttempts: 0,
          accuracy: 0,
          lastRating: null
        };
      }

      normalizeProgress(progress, now = Date.now()) {
        const base = this.createProgress(now);
        const normalized = { ...base, ...(progress || {}) };
        normalized.due = typeof normalized.due === 'number' && !Number.isNaN(normalized.due)
          ? normalized.due
          : now;
        normalized.interval = typeof normalized.interval === 'number' && !Number.isNaN(normalized.interval)
          ? normalized.interval
          : 0;
        normalized.accuracy = normalized.totalAttempts > 0
          ? normalized.correctAttempts / normalized.totalAttempts
          : 0;
        normalized.state = normalized.state || 'new';
        normalized.consecutiveCorrect = normalized.consecutiveCorrect || 0;
        normalized.bestStreak = normalized.bestStreak || 0;
        normalized.reps = normalized.reps || 0;
        normalized.lapses = normalized.lapses || 0;
        return normalized;
      }

      createModeProgressSet(existing = {}, now = Date.now()) {
        const result = {};
        MODE_IDS.forEach(mode => {
          result[mode] = this.normalizeProgress(existing[mode], now);
        });
        return result;
      }

      updateProgress(progress, rating, options = {}) {
        const now = Date.now();
        const base = this.normalizeProgress(progress, now);
        const updated = { ...base };

        if (base.reps === 0) {
          updated.difficulty = this.initDifficulty(rating);
          updated.stability = this.initStability(rating);
          updated.retrievability = 1;
        } else {
          const elapsedDays = base.last_review ? (now - base.last_review) / DAY_IN_MS : 0;
          updated.retrievability = this.forgettingCurve(elapsedDays, base.stability);
          const nextDifficulty = this.nextDifficulty(base.difficulty, rating);
          updated.difficulty = nextDifficulty;
          updated.stability = this.nextStability(
            nextDifficulty,
            base.stability,
            updated.retrievability,
            rating
          );
        }

        updated.reps = base.reps + 1;
        if (rating === 1) {
          updated.lapses = base.lapses + 1;
        }

        if (rating >= 3) {
          updated.consecutiveCorrect = base.consecutiveCorrect + 1;
          updated.correctAttempts = base.correctAttempts + 1;
          if (options.stabilityBonus) {
            updated.stability *= 1 + options.stabilityBonus;
          }
          if (options.difficultyBonus) {
            updated.difficulty = this.constrainDifficulty(updated.difficulty - options.difficultyBonus);
          }
        } else {
          updated.consecutiveCorrect = 0;
          if (options.degradeOnFail) {
            updated.stability = Math.max(updated.stability * 0.6, 0.05);
            updated.difficulty = this.constrainDifficulty(updated.difficulty + 0.5);
          }
        }

        updated.bestStreak = Math.max(base.bestStreak, updated.consecutiveCorrect);
        updated.totalAttempts = base.totalAttempts + 1;
        updated.accuracy = updated.totalAttempts > 0
          ? updated.correctAttempts / updated.totalAttempts
          : 0;

        updated.last_review = now;
        updated.lastRating = rating;

        updated.interval = this.nextInterval(updated.stability);
        updated.due = now + updated.interval * DAY_IN_MS;

        updated.state = this.getProgressState(updated);

        return updated;
      }

      aggregateWord(word) {
        if (!word) return word;
        const now = Date.now();
        const modeProgress = this.createModeProgressSet(word.modeProgress, now);
        const aggregated = { ...word, modeProgress };

        let difficultySum = 0;
        let stabilitySum = 0;
        let retrievabilitySum = 0;
        let repsSum = 0;
        let lapsesSum = 0;
        let lastReview = 0;
        let earliestDue = Infinity;
        let shortestInterval = Infinity;
        let masteredModes = 0;
        let activeModes = 0;
        let strugglingModes = 0;

        MODE_IDS.forEach(mode => {
          const progress = modeProgress[mode];
          difficultySum += progress.difficulty;
          stabilitySum += progress.stability;
          retrievabilitySum += progress.retrievability || 0;
          repsSum += progress.reps;
          lapsesSum += progress.lapses;
          if (progress.last_review) {
            lastReview = Math.max(lastReview, progress.last_review);
          }
          if (typeof progress.due === 'number' && !Number.isNaN(progress.due)) {
            earliestDue = Math.min(earliestDue, progress.due);
          }
          if (typeof progress.interval === 'number' && progress.interval > 0) {
            shortestInterval = Math.min(shortestInterval, progress.interval);
          }
          if (progress.state === 'mastered') {
            masteredModes += 1;
          }
          if (progress.reps > 0) {
            activeModes += 1;
          }
          const attempts = progress.totalAttempts || 0;
          const correct = progress.correctAttempts || 0;
          if (attempts >= 3 && (attempts - correct) / attempts >= 0.4) {
            strugglingModes += 1;
          }
        });

        const modeCount = MODE_IDS.length || 1;
        aggregated.difficulty = difficultySum / modeCount;
        aggregated.stability = stabilitySum / modeCount;
        aggregated.retrievability = retrievabilitySum / modeCount;
        aggregated.reps = repsSum;
        aggregated.lapses = lapsesSum;
        aggregated.last_review = lastReview || null;
        aggregated.due = Number.isFinite(earliestDue) ? earliestDue : now;
        aggregated.interval = Number.isFinite(shortestInterval) ? shortestInterval : 0;
        aggregated.masteredModes = masteredModes;
        aggregated.activeModes = activeModes;

        if (masteredModes >= 2) {
          aggregated.state = 'mastered';
        } else if (activeModes >= 2 && strugglingModes === 0) {
          aggregated.state = 'reviewing';
        } else if (activeModes > 0) {
          aggregated.state = 'learning';
        } else {
          aggregated.state = 'new';
        }

        return aggregated;
      }

      getProgressState(progress) {
        if (!progress || progress.reps === 0) return 'new';
        const accuracy = progress.accuracy || 0;
        if (progress.consecutiveCorrect >= 5 && accuracy >= 0.9 && progress.interval >= 21) {
          return 'mastered';
        }
        if (progress.consecutiveCorrect >= 3 && accuracy >= 0.75) {
          return 'reviewing';
        }
        if (accuracy < 0.6 || progress.lapses >= 2) {
          return 'learning';
        }
        return 'learning';
      }

      getDifficultyLevel(difficulty) {
        if (difficulty <= 3) return 'easy';
        if (difficulty <= 7) return 'medium';
        return 'hard';
      }

      updateWord(word, rating, modeKey, options = {}) {
        if (!modeKey) return this.aggregateWord(word);
        const now = Date.now();
        const working = { ...word };
        working.modeProgress = this.createModeProgressSet(working.modeProgress, now);
        const progress = working.modeProgress[modeKey];
        const updatedProgress = this.updateProgress(progress, rating, options);
        working.modeProgress[modeKey] = updatedProgress;
        return this.aggregateWord(working);
      }
    }

    // ==================== 主应用 ====================
    class VocabularyApp {
      constructor() {
        this.fsrs = new FSRS();
        this.library = [];
        this.dueWords = [];
        this.stage = 'library';
        this.currentMode = 0;
        this.currentIndex = 0;
        this.answer = '';
        this.feedback = null;
        this.isAnswered = false;
        this.stats = { correct: 0, incorrect: 0 };
        this.updatedWords = [];
        this.finalStats = null;
        this.searchTerm = '';
        this.contentContainer = null;
        this.isInitialized = false;
        this.attemptLog = [];
        this.repeatQueue = [];
        this.lastScrollY = 0;
        this.sessionBaseline = {};
        this.sessionResults = {};

        this.handleSearchInput = this.handleSearchInput.bind(this);

        this.practiceSettings = {
          filter: 'due',
          sort: 'smart',
          quantity: 20
        };

        this.loadLibrary();
        this.render();
      }

      loadLibrary() {
        try {
          const stored = localStorage.getItem('wordLibrary_v2');
          if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
              this.library = parsed
                .map(item => this.normalizeWord(item))
                .filter(Boolean);
            }
          }
        } catch (e) {
          console.error('Load error:', e);
          localStorage.removeItem('wordLibrary_v2');
        }
      }

      saveLibrary() {
        try {
          const normalized = this.library.map(word => this.fsrs.aggregateWord(word));
          this.library = normalized;
          localStorage.setItem('wordLibrary_v2', JSON.stringify(normalized));
        } catch (e) {
          console.error('Save error:', e);
          alert('保存失败，可能是存储空间不足！');
        }
      }

      normalizeWord(rawWord) {
        if (!rawWord || !rawWord.english) return null;
        const now = Date.now();
        const english = String(rawWord.english || '').trim();
        if (!english) return null;

        const chineseList = Array.isArray(rawWord.chinese)
          ? rawWord.chinese
          : typeof rawWord.chinese === 'string'
            ? rawWord.chinese.split(/[,，;；、]/)
            : [];
        const sanitizedChinese = chineseList
          .map(item => String(item || '').trim())
          .filter(Boolean);

        let modeProgress;
        if (rawWord.modeProgress) {
          modeProgress = this.fsrs.createModeProgressSet(rawWord.modeProgress, now);
        } else {
          const legacyProgress = this.fsrs.normalizeProgress({
            difficulty: rawWord.difficulty,
            stability: rawWord.stability,
            reps: rawWord.reps,
            lapses: rawWord.lapses,
            last_review: rawWord.last_review,
            due: rawWord.due,
            retrievability: rawWord.retrievability,
            interval: rawWord.interval
          }, now);
          modeProgress = this.fsrs.createModeProgressSet({}, now);
          modeProgress['1'] = legacyProgress;
        }

        const word = {
          english,
          chinese: sanitizedChinese.length ? sanitizedChinese : [''],
          isStarred: !!rawWord.isStarred,
          modeProgress
        };

        return this.fsrs.aggregateWord(word);
      }

      addWords(text) {
        if (!text || !text.trim()) {
          alert('请输入单词！');
          return;
        }

        const lines = text.trim().split('\n');
        const newWords = [];
        const now = Date.now();
        let duplicates = 0;

        lines.forEach(raw => {
          const line = raw.trim();
          if (!line) return;

          const parts = line.split(/\s+/).filter(Boolean);
          if (parts.length < 2) return;

          let splitIndex = -1;
          for (let i = 1; i < parts.length; i++) {
            const token = parts[i];
            const hasChinese = /[\u4e00-\u9fa5]/.test(token);
            const isEnglishLike = /^[a-zA-Z0-9'\/-]+$/.test(token);
            if (hasChinese || !isEnglishLike) {
              splitIndex = i;
              break;
            }
          }

          if (splitIndex === -1) {
            splitIndex = 1;
          }

          const englishParts = parts.slice(0, splitIndex).map(p => p.toLowerCase());
          const chineseParts = parts.slice(splitIndex);

          const english = englishParts.join(' ').replace(/\s+/g, ' ').trim();
          const chineseText = chineseParts.join(' ').trim();
          if (!english || !chineseText || /[\u4e00-\u9fa5]/.test(english)) return;

          const translations = chineseText
            .split(/[,，;；、]/)
            .map(t => t.trim())
            .filter(t => t);

          if (translations.length === 0) return;

          const exists = this.library.find(w => w.english === english);
          if (!exists) {
            const word = {
              english,
              chinese: translations,
              isStarred: false,
              modeProgress: this.fsrs.createModeProgressSet({}, now)
            };
            newWords.push(this.fsrs.aggregateWord(word));
          } else {
            duplicates++;
          }
        });

        if (newWords.length > 0) {
          this.library = [...this.library, ...newWords];
          this.saveLibrary();
          let msg = `成功添加 ${newWords.length} 个新单词！`;
          if (duplicates > 0) {
            msg += `\n跳过 ${duplicates} 个重复单词。`;
          }
          alert(msg);
          this.render();
        } else {
          alert(duplicates > 0 ? `所有单词都已存在！` : '没有有效的单词格式！');
        }
      }
      
      toggleStar(english) {
        const word = this.library.find(w => w.english === english);
        if (word) {
          word.isStarred = !word.isStarred;
          this.saveLibrary();
          this.render();
        }
      }

      startPractice() {
        if (this.library.length === 0) {
          alert('词库为空！请先添加单词。');
          return;
        }

        this.practiceSettings.filter = 'due';
        this.practiceSettings.sort = 'smart';

        this.stage = 'settings';
        this.render();
      }
      
      startQuickPractice(filter) {
        const words = this.getFilteredWords(filter);
        if (words.length === 0) {
          alert(`暂无${filter === 'new' ? '新' : '收藏的'}单词！`);
          return;
        }

        const selected = this.getSortedWords(words, 'smart').slice(0, 20);
        this.launchPracticeFlow(selected);
      }

      startConfiguredPractice() {
        let filtered = this.getFilteredWords(this.practiceSettings.filter);
        if (filtered.length === 0) {
          alert('当前筛选条件下没有可练习的单词！');
          return;
        }

        let sorted = this.getSortedWords(filtered, this.practiceSettings.sort);

        const selected = sorted.slice(0, this.practiceSettings.quantity);
        this.launchPracticeFlow(selected);
      }

      launchPracticeFlow(words) {
        this.dueWords = Array.isArray(words) ? words : [];
        this.stage = 'mode';
        this.render();
      }

      selectMode(mode) {
        this.currentMode = mode;
        this.currentIndex = 0;
        this.answer = '';
        this.feedback = null;
        this.isAnswered = false;
        this.stats = { correct: 0, incorrect: 0 };
        this.attemptLog = [];
        this.repeatQueue = [];
        this.sessionBaseline = {};
        this.dueWords.forEach(word => {
          this.sessionBaseline[word.english] = word.masteredModes || 0;
        });
        this.updatedWords = JSON.parse(JSON.stringify(this.dueWords));
        this.sessionResults = {};
        this.updatedWords.forEach(word => {
          this.sessionResults[word.english] = word;
        });
        this.stage = 'practice';
        this.render();

        setTimeout(() => {
          if (mode === 1 || mode === 3) {
            this.playAudio();
          }
          const input = document.getElementById('answerInput');
          if (input) input.focus();
        }, 300);
      }

      playAudio() {
        const word = this.updatedWords[this.currentIndex];
        if (!word || !window.speechSynthesis) {
          console.warn('语音功能不可用');
          return;
        }
        
        try {
          window.speechSynthesis.cancel();
          const utter = new SpeechSynthesisUtterance(word.english);
          utter.lang = 'en-US';
          utter.rate = 0.85;
          utter.pitch = 1.0;
          utter.volume = 1.0;
          
          utter.onerror = (e) => {
            console.error('Speech error:', e);
          };
          
          window.speechSynthesis.speak(utter);
        } catch (e) {
          console.error('Speech error:', e);
        }
      }

      checkAnswer() {
        if (this.isAnswered) {
          this.handleNext();
          return;
        }

        const text = this.answer.trim();
        if (!text) {
          alert('⚠️ 请输入答案！');
          return;
        }

        const word = this.updatedWords[this.currentIndex];
        let isCorrect = false;
        const modeKey = String(this.currentMode);
        const modeConfig = MODE_CONFIG[this.currentMode] || {
          successRating: 4,
          stabilityBonus: 0,
          difficultyBonus: 0
        };

        if (this.currentMode === 1) {
          isCorrect = word.chinese.some(t => {
            const normalized = text.toLowerCase().replace(/\s+/g, '');
            const target = t.toLowerCase().replace(/\s+/g, '');
            return normalized.includes(target) || target.includes(normalized);
          });
        }
        else if (this.currentMode === 2) {
          const normalized = text.toLowerCase().trim();
          isCorrect = normalized === word.english.toLowerCase();
        }
        else if (this.currentMode === 3) {
          const parts = text.split(/\s+/);
          if (parts.length >= 2) {
            const answerEn = parts[0].toLowerCase().trim();
            const answerCn = parts.slice(1).join(' ').toLowerCase().replace(/\s+/g, '');
            
            const englishCorrect = answerEn === word.english.toLowerCase();
            const chineseCorrect = word.chinese.some(t => {
              const target = t.toLowerCase().replace(/\s+/g, '');
              return answerCn.includes(target) || target.includes(answerCn);
            });
            
            isCorrect = englishCorrect && chineseCorrect;
          }
        }

        if (isCorrect) {
          this.stats.correct += 1;
          this.feedback = { type: 'correct', text: '✓ 正确！很棒！' };
        } else {
          this.stats.incorrect += 1;
          const correctAns = this.currentMode === 2
            ? word.english
            : this.currentMode === 3
              ? `${word.english} ${word.chinese.join('，')}`
              : word.chinese.join('，');
          this.feedback = { type: 'incorrect', text: `✗ 错误！正确答案：${correctAns}` };
        }

        const rating = isCorrect ? modeConfig.successRating : 1;
        const updated = this.fsrs.updateWord(word, rating, modeKey, {
          stabilityBonus: isCorrect ? modeConfig.stabilityBonus : 0,
          difficultyBonus: isCorrect ? modeConfig.difficultyBonus : 0,
          degradeOnFail: true
        });
        this.updatedWords[this.currentIndex] = updated;
        this.sessionResults[updated.english] = updated;
        this.attemptLog.push({
          english: word.english,
          mode: this.currentMode,
          correct: isCorrect,
          rating
        });
        if (!isCorrect) {
          const scheduled = this.repeatQueue.find(item => item.english === updated.english);
          if (!scheduled) {
            const repeatCopy = JSON.parse(JSON.stringify(updated));
            repeatCopy._originMode = this.currentMode;
            this.repeatQueue.push(repeatCopy);
          }
        }
        this.isAnswered = true;
        this.render();

        if (isCorrect) {
          setTimeout(() => this.handleNext(), 1200);
        }
      }

      handleNext() {
        if (this.currentIndex + 1 >= this.updatedWords.length) {
          if (this.repeatQueue.length > 0) {
            const repeats = this.repeatQueue.map(word => this.fsrs.aggregateWord(word));
            this.updatedWords = [...this.updatedWords, ...repeats];
            this.repeatQueue = [];
          } else {
            this.completePractice();
            return;
          }
        }

        this.currentIndex += 1;

        this.answer = '';
        this.feedback = null;
        this.isAnswered = false;
        this.render();

        setTimeout(() => {
          if (this.currentMode === 1 || this.currentMode === 3) {
            this.playAudio();
          }
          const input = document.getElementById('answerInput');
          if (input) input.focus();
        }, 100);
      }

      skipQuestion() {
        const word = this.updatedWords[this.currentIndex];
        const modeKey = String(this.currentMode);
        const updated = this.fsrs.updateWord(word, 1, modeKey, {
          degradeOnFail: true
        });
        this.updatedWords[this.currentIndex] = updated;
        this.sessionResults[updated.english] = updated;
        this.stats.incorrect += 1;
        this.attemptLog.push({
          english: word.english,
          mode: this.currentMode,
          correct: false,
          rating: 1
        });
        const scheduled = this.repeatQueue.find(item => item.english === updated.english);
        if (!scheduled) {
          const repeatCopy = JSON.parse(JSON.stringify(updated));
          repeatCopy._originMode = this.currentMode;
          this.repeatQueue.push(repeatCopy);
        }

        const correctAns = this.currentMode === 2
          ? word.english
          : this.currentMode === 3
            ? `${word.english} ${word.chinese.join('，')}`
            : word.chinese.join('，');

        this.feedback = { type: 'incorrect', text: `✗ 错误！正确答案：${correctAns}` };
        this.isAnswered = true;
        this.render();
      }

      completePractice() {
        const finalResults = Object.values(this.sessionResults);
        this.updatedWords = finalResults;
        this.library = this.library.map(w => {
          const updated = this.sessionResults[w.english];
          return updated ? this.fsrs.aggregateWord(updated) : w;
        });
        this.saveLibrary();

        this.finalStats = {
          ...this.stats,
          totalWords: finalResults.length,
          totalAttempts: this.attemptLog.length,
          accuracy: this.attemptLog.length > 0
            ? Math.round((this.stats.correct / this.attemptLog.length) * 100)
            : 0,
          masteredWords: finalResults.filter(w => (w.masteredModes || 0) >= 2).length,
          newlyMastered: finalResults.filter(w => {
            const baseline = this.sessionBaseline[w.english] || 0;
            return baseline < 2 && (w.masteredModes || 0) >= 2;
          }).length,
          repeatAttempts: Math.max(this.attemptLog.length - finalResults.length, 0)
        };

        this.repeatQueue = [];
        this.stage = 'complete';
        this.render();
      }

      deleteWord(english) {
        if (!confirm(`确定要删除单词「${english}」吗？`)) {
          return;
        }
        
        this.library = this.library.filter(w => w.english !== english);
        this.saveLibrary();
        this.render();
      }

      resetWord(english) {
        if (!confirm(`确定要重置单词「${english}」的学习进度吗？`)) {
          return;
        }
        
        const now = Date.now();
        this.library = this.library.map(w => {
          if (w.english === english) {
            const resetWord = {
              ...w,
              isStarred: w.isStarred,
              modeProgress: this.fsrs.createModeProgressSet({}, now)
            };
            return this.fsrs.aggregateWord(resetWord);
          }
          return w;
        });
        this.saveLibrary();
        this.render();
      }

      clearLibrary() {
        if (!confirm('⚠️ 确定要清空所有词库吗？此操作不可恢复！')) {
          return;
        }
        
        if (!confirm('⚠️⚠️ 再次确认：真的要删除所有单词吗？')) {
          return;
        }
        
        this.library = [];
        this.saveLibrary();
        this.render();
        alert('✓ 词库已清空');
      }

      getStats() {
        const now = Date.now();
        return {
          total: this.library.length,
          due: this.library.filter(w => w.due <= now).length,
          learning: this.library.filter(w => w.state === 'learning').length,
          mastered: this.library.filter(w => w.state === 'mastered').length,
          new: this.library.filter(w => w.state === 'new').length,
          starred: this.library.filter(w => w.isStarred).length,
        };
      }
      
      getFilteredWords(filter) {
        const now = Date.now();
        switch (filter) {
          case 'due': return this.library.filter(w => w.due <= now);
          case 'new': return this.library.filter(w => w.state === 'new');
          case 'hard': return this.library.filter(w => w.difficulty >= 7);
          case 'starred': return this.library.filter(w => w.isStarred);
          case 'all': default: return [...this.library];
        }
      }

      getSortedWords(words, sort) {
        const now = Date.now();
        let sorted = [...words];
        switch (sort) {
          case 'smart':
            sorted.sort((a, b) => {
              const aR = a.last_review ? this.fsrs.forgettingCurve((now - a.last_review) / (1000 * 60 * 60 * 24), a.stability) : 0;
              const bR = b.last_review ? this.fsrs.forgettingCurve((now - b.last_review) / (1000 * 60 * 60 * 24), b.stability) : 0;
              return aR - bR;
            });
            break;
          case 'random':
            sorted.sort(() => Math.random() - 0.5);
            break;
          case 'newFirst':
            sorted.sort((a, b) => a.reps - b.reps);
            break;
          case 'errorFirst':
            sorted.sort((a, b) => b.lapses - a.lapses);
            break;
          case 'added':
            sorted.sort((a, b) => this.library.indexOf(a) - this.library.indexOf(b));
            break;
        }
        return sorted;
      }
      
      selectFilter(filter) {
        this.practiceSettings.filter = filter;
        this.render();
      }
      
      selectSort(sort) {
        this.practiceSettings.sort = sort;
        this.render();
      }
      
      updateQuantity(value) {
        this.practiceSettings.quantity = parseInt(value, 10);
        this.render();
      }

      exportLibrary() {
        if (this.library.length === 0) {
          alert('词库为空，无法导出！');
          return;
        }
        
        const data = JSON.stringify(this.library, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `vocabulary_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      importLibrary() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const imported = JSON.parse(event.target.result);
              if (!Array.isArray(imported)) {
                throw new Error('Invalid format');
              }
              
              let added = 0;
              imported.forEach(word => {
                const normalized = this.normalizeWord(word);
                if (normalized && !this.library.find(w => w.english === normalized.english)) {
                  this.library.push(normalized);
                  added++;
                }
              });
              
              this.saveLibrary();
              alert(`✓ 成功导入 ${added} 个单词！`);
              this.render();
            } catch (err) {
              alert('❌ 导入失败：文件格式错误！');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      render(forceFull = false) {
        const app = document.getElementById('app');
        if (!app) return;

        if (this.stage === 'library') {
          this.lastScrollY = window.scrollY;
        } else {
          this.lastScrollY = 0;
        }

        if (!this.isInitialized || forceFull) {
          app.innerHTML = `
            <div class="container">
              <div class="card">
                ${this.renderHeader()}
                <div class="content"></div>
              </div>
              ${this.renderFooter()}
            </div>
          `;
          this.contentContainer = app.querySelector('.content');
          this.isInitialized = true;
        }

        if (this.contentContainer) {
          this.contentContainer.innerHTML = this.renderStage();
        }

        this.attachEventListeners();

        const targetScroll = this.stage === 'library' ? this.lastScrollY : 0;
        window.requestAnimationFrame(() => {
          window.scrollTo(0, targetScroll);
        });
      }

      renderHeader() {
        return `
          <div class="header">
            <h1>🎯 智能单词学习系统</h1>
            <p>基于 FSRS 算法的高效记忆助手</p>
          </div>
        `;
      }

      renderFooter() {
        return `
          <div class="footer">
            💡 提示：首次使用请允许浏览器的语音播放权限 | FSRS Algorithm v4.5
          </div>
        `;
      }

      renderStage() {
        switch (this.stage) {
          case 'library': return this.renderLibrary();
          case 'settings': return this.renderSettings();
          case 'mode': return this.renderModeSelect();
          case 'practice': return this.renderPractice();
          case 'complete': return this.renderComplete();
          default: return '<div class="loading">加载中...</div>';
        }
      }

      renderLibrary() {
        const stats = this.getStats();
        return `
          <div>
            <div class="stats-grid">
              <div class="stat-card blue">
                <div class="stat-value">${stats.total}</div>
                <div class="stat-label">总词汇量</div>
              </div>
              <div class="stat-card red">
                <div class="stat-value">${stats.due}</div>
                <div class="stat-label">待复习</div>
              </div>
              <div class="stat-card yellow">
                <div class="stat-value">${stats.learning}</div>
                <div class="stat-label">学习中</div>
              </div>
              <div class="stat-card green">
                <div class="stat-value">${stats.mastered}</div>
                <div class="stat-label">已熟练</div>
              </div>
            </div>

            <div class="section">
              <h2 class="section-title">🚀 快捷开始</h2>
              <div class="stats-grid">
                <div class="stat-card quick-start" id="quickStartNew">
                  <div class="stat-value">🆕 ${stats.new}</div>
                  <div class="stat-label">练习新单词</div>
                </div>
                <div class="stat-card quick-start" id="quickStartStarred">
                  <div class="stat-value">⭐ ${stats.starred}</div>
                  <div class="stat-label">练习收藏</div>
                </div>
              </div>
            </div>
            
            <div class="button-group" style="margin-bottom: 40px;">
              <button class="btn-primary" id="startPracticeBtn" ${stats.total === 0 ? 'disabled' : ''}>
                ⚙️ 配置并开始学习 (${stats.due})
              </button>
            </div>

            <div class="section">
              <h2 class="section-title">📝 添加新单词</h2>
              <p class="section-desc">
                格式：英文单词 中文翻译（多个翻译用逗号分隔）<br>
                示例：apple 苹果 | important 重要的,有重要意义的
              </p>
              <textarea id="wordInput" placeholder="important 重要的&#10;cool 凉爽,凉快,很酷的&#10;exact 精确的&#10;question 题目,问题&#10;many 很多,多种&#10;school 学校,学院"></textarea>
              <div class="button-group">
                <button class="btn-primary" id="addWordsBtn">📚 添加到词库</button>
              </div>
            </div>

            <div class="section">
              <h2 class="section-title">📚 词库管理</h2>
              <div class="button-group">
                <button class="btn-secondary" id="exportBtn">💾 导出词库</button>
                <button class="btn-secondary" id="importBtn">📂 导入词库</button>
                <button class="btn-danger" id="clearBtn">🗑️ 清空词库</button>
              </div>
            </div>

            ${this.renderWordList()}
          </div>
        `;
      }

      getProgressStateLabel(state) {
        const map = {
          new: '待启动',
          learning: '学习中',
          reviewing: '巩固中',
          mastered: '已熟练'
        };
        return map[state] || state;
      }

      getWordAverageAccuracy(word) {
        if (!word || !word.modeProgress) return 0;
        const total = MODE_IDS.reduce((sum, mode) => {
          const progress = word.modeProgress[mode];
          return sum + (progress ? progress.accuracy || 0 : 0);
        }, 0);
        return Math.round((total / MODE_IDS.length) * 100);
      }

      renderModeBadges(word) {
        if (!word || !word.modeProgress) return '';
        return `
          <div class="mode-progress-row">
            ${MODE_IDS.map(mode => {
              const progress = word.modeProgress[mode];
              const config = MODE_CONFIG[mode];
              if (!progress || !config) return '';
              const accuracy = Math.round((progress.accuracy || 0) * 100);
              const stateLabel = this.getProgressStateLabel(progress.state);
              return `
                <span class="mode-progress-badge ${progress.state}">
                  ${config.label} · ${stateLabel} · ${accuracy}%
                </span>
              `;
            }).join('')}
          </div>
        `;
      }

      renderWordList() {
        const now = Date.now();
        const term = this.searchTerm.toLowerCase();
        let displayWords = this.library;

        if (term) {
          displayWords = this.library.filter(w => 
            w.english.toLowerCase().includes(term) || 
            w.chinese.some(c => c.toLowerCase().includes(term))
          );
        }

        if (displayWords.length === 0) {
          return `
            <div id="wordListSection" class="section">
              <h2 class="section-title">📖 单词列表</h2>
              <input type="search" id="searchInput" placeholder="🔍 搜索单词..." />
              <div style="text-align: center; padding: 40px; color: #64748b;">
                ${term ? '没有找到匹配的单词' : '词库为空，请先添加单词'}
              </div>
            </div>
          `;
        }

        return `
          <div id="wordListSection" class="section">
            <h2 class="section-title">📖 单词列表 (${displayWords.length})</h2>
            <input type="search" id="searchInput" placeholder="🔍 搜索单词..." />
            <div class="word-list">
              ${displayWords.map(word => {
                const isDue = word.due <= now;
                const difficultyLevel = this.fsrs.getDifficultyLevel(word.difficulty);
                return `
                  <div class="word-item ${isDue ? 'is-due' : ''}" style="position: relative;">
                    <span class="word-star ${word.isStarred ? 'starred' : ''}" onclick="app.toggleStar('${word.english}')">
                      ${word.isStarred ? '⭐' : '☆'}
                    </span>
                    <div class="word-main">
                      <div class="word-english">${word.english}</div>
                      <div class="word-chinese">${word.chinese.join('，')}</div>
                      ${this.renderModeBadges(word)}
                    </div>
                    <div class="word-stats">
                      <span class="difficulty-badge difficulty-${difficultyLevel}">
                        难度 ${word.difficulty.toFixed(1)}
                      </span>
                      <span>复习 ${word.reps} 次</span>
                      <span>间隔 ${word.interval} 天</span>
                      <span>掌握模式 ${word.masteredModes || 0}/${MODE_IDS.length}</span>
                      <span>平均正确率 ${this.getWordAverageAccuracy(word)}%</span>
                      ${isDue ? '<span style="color: #dc2626; font-weight: 600;">待复习</span>' : ''}
                      <button onclick="app.resetWord('${word.english}')" style="padding: 5px 10px; font-size: 12px; background: #fef3c7; color: #d97706; border: none; border-radius: 5px; cursor: pointer;">重置</button>
                      <button onclick="app.deleteWord('${word.english}')" style="padding: 5px 10px; font-size: 12px; background: #fee2e2; color: #dc2626; border: none; border-radius: 5px; cursor: pointer;">删除</button>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }

      renderSettings() {
        const counts = {
          due: this.getFilteredWords('due').length,
          all: this.getFilteredWords('all').length,
          new: this.getFilteredWords('new').length,
          hard: this.getFilteredWords('hard').length,
          starred: this.getFilteredWords('starred').length,
        };
        
        const currentFilter = this.practiceSettings.filter;
        const currentSort = this.practiceSettings.sort;
        const currentQuantity = this.practiceSettings.quantity;
        const availableCount = counts[currentFilter];
        const isQuantityInvalid = currentQuantity > availableCount;
        const canStart = availableCount > 0;
        
        return `
          <div class="settings-container">
            <h2 class="section-title">1. 筛选练习单词</h2>
            <p class="section-desc">选择你本次想练习的单词范围。</p>
            <div class="settings-grid">
              <div class="setting-card ${currentFilter === 'due' ? 'active' : ''}" onclick="app.selectFilter('due')">
                <div class="setting-card-title">📅 待复习</div>
                <div class="setting-card-desc">只练到期单词</div>
                <div class="setting-card-count">${counts.due}</div>
              </div>
              <div class="setting-card ${currentFilter === 'all' ? 'active' : ''}" onclick="app.selectFilter('all')">
                <div class="setting-card-title">📚 全部单词</div>
                <div class="setting-card-desc">练习所有单词</div>
                <div class="setting-card-count">${counts.all}</div>
              </div>
              <div class="setting-card ${currentFilter === 'new' ? 'active' : ''}" onclick="app.selectFilter('new')">
                <div class="setting-card-title">🆕 新单词</div>
                <div class="setting-card-desc">只练新添加的</div>
                <div class="setting-card-count">${counts.new}</div>
              </div>
              <div class="setting-card ${currentFilter === 'hard' ? 'active' : ''}" onclick="app.selectFilter('hard')">
                <div class="setting-card-title">🔥 困难单词</div>
                <div class="setting-card-desc">难度≥7的单词</div>
                <div class="setting-card-count">${counts.hard}</div>
              </div>
              <div class="setting-card ${currentFilter === 'starred' ? 'active' : ''}" onclick="app.selectFilter('starred')">
                <div class="setting-card-title">⭐ 收藏单词</div>
                <div class="setting-card-desc">你收藏的重点</div>
                <div class="setting-card-count">${counts.starred}</div>
              </div>
            </div>
            
            <h2 class="section-title">2. 智能排序</h2>
            <p class="section-desc">选择单词出现的顺序。</p>
            <div class="settings-grid">
              <div class="setting-card ${currentSort === 'smart' ? 'active' : ''}" onclick="app.selectSort('smart')">
                <div class="setting-card-title">🧠 智能推荐</div>
                <div class="setting-card-desc">FSRS算法排序</div>
              </div>
              <div class="setting-card ${currentSort === 'random' ? 'active' : ''}" onclick="app.selectSort('random')">
                <div class="setting-card-title">🎲 随机顺序</div>
                <div class="setting-card-desc">打乱顺序</div>
              </div>
              <div class="setting-card ${currentSort === 'added' ? 'active' : ''}" onclick="app.selectSort('added')">
                <div class="setting-card-title">📝 添加顺序</div>
                <div class="setting-card-desc">按添加顺序</div>
              </div>
              <div class="setting-card ${currentSort === 'newFirst' ? 'active' : ''}" onclick="app.selectSort('newFirst')">
                <div class="setting-card-title">🌱 新词优先</div>
                <div class="setting-card-desc">复习次数少</div>
              </div>
              <div class="setting-card ${currentSort === 'errorFirst' ? 'active' : ''}" onclick="app.selectSort('errorFirst')">
                <div class="setting-card-title">❌ 错误优先</div>
                <div class="setting-card-desc">遗忘次数多</div>
              </div>
            </div>
            
            <div class="slider-container">
              <div class="slider-label">
                <span>3. 练习数量 (可选: ${availableCount}个)</span>
                <span class="slider-value">${currentQuantity}</span>
              </div>
              <input 
                type="range" 
                id="quantitySlider" 
                min="5" 
                max="100" 
                value="${currentQuantity}" 
                step="5"
                ${!canStart ? 'disabled' : ''}
              />
              ${isQuantityInvalid && canStart ? `
                <div class="warning-text">
                  ⚠️ 警告：所选数量 (${currentQuantity}) 超出可用单词数 (${availableCount})，将只练习 ${availableCount} 个。
                </div>
              ` : ''}
              ${!canStart ? `
                <div class="warning-text">
                  🤷‍♂️ 当前筛选条件下没有可练习的单词。
                </div>
              ` : ''}
            </div>

            <div class="button-group">
              <button class="btn-primary" id="startConfiguredPracticeBtn" ${!canStart ? 'disabled' : ''}>
                🚀 开始练习 (${Math.min(currentQuantity, availableCount)})
              </button>
              <button class="btn-secondary" id="backToLibraryBtn">
                ← 返回词库
              </button>
            </div>
          </div>
        `;
      }

      renderModeSelect() {
        return `
          <div>
            <h2 class="section-title" style="text-align: center;">选择练习模式</h2>
            <p class="section-desc" style="text-align: center;">
              本次将练习 <strong>${this.dueWords.length}</strong> 个单词，单词需在至少两种模式下达标才会记为“已熟练”
            </p>

            <div class="mode-grid">
              <div class="mode-card" data-mode="1">
                <div class="mode-icon">🎧</div>
                <div class="mode-title">英译中</div>
                <div class="mode-desc">看英文，说出中文意思</div>
              </div>
              
              <div class="mode-card" data-mode="2">
                <div class="mode-icon">✍️</div>
                <div class="mode-title">中译英</div>
                <div class="mode-desc">看中文，拼写英文单词</div>
              </div>
              
              <div class="mode-card" data-mode="3">
                <div class="mode-icon">🔊</div>
                <div class="mode-title">听写模式</div>
                <div class="mode-desc">听发音，写出单词和释义</div>
              </div>
            </div>

            <button class="btn-secondary" id="backToSettingsBtn" style="width: 100%; margin-top: 20px;">
              ← 返回设置
            </button>
          </div>
        `;
      }

      renderPractice() {
        const word = this.updatedWords[this.currentIndex];
        if (!word) {
          return '<div class="loading">加载中...</div>';
        }

        const progress = ((this.currentIndex + 1) / this.updatedWords.length) * 100;
        
        let promptText = '';
        let placeholder = '';
        let showAudioBtn = false;
        let showPrompt = true;

        if (this.currentMode === 1) {
          promptText = word.english;
          placeholder = '输入中文翻译';
          showAudioBtn = true;
        } else if (this.currentMode === 2) {
          promptText = word.chinese.join('，');
          placeholder = '输入英文单词';
        } else if (this.currentMode === 3) {
          placeholder = '格式：英文单词 中文翻译';
          showAudioBtn = true;
          showPrompt = false;
        }

        return `
          <div class="practice-container">
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${progress}%"></div>
            </div>

            <div class="stats-row">
              <div class="stat-item">
                <div class="stat-item-label">进度</div>
                <div class="stat-item-value purple">${this.currentIndex + 1}/${this.updatedWords.length}</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-label">正确</div>
                <div class="stat-item-value green">${this.stats.correct}</div>
              </div>
              <div class="stat-item">
                <div class="stat-item-label">错误</div>
                <div class="stat-item-value red">${this.stats.incorrect}</div>
              </div>
            </div>

            <div class="question-card">
              ${showAudioBtn ? `
                <button class="audio-btn" id="playAudioBtn">
                  🔊 ${this.currentMode === 3 ? '播放单词' : '播放发音'}
                </button>
              ` : ''}
              
              ${showPrompt ? `
                <div class="prompt-text">${promptText}</div>
              ` : `
                <div style="text-align: center; color: #64748b; font-size: 16px; margin: 20px 0;">
                  点击上方按钮播放音频，然后输入答案
                </div>
              `}

              ${this.feedback ? `
                <div class="feedback ${this.feedback.type}">
                  ${this.feedback.text}
                </div>
              ` : ''}

              <input
                type="text"
                id="answerInput"
                value="${this.answer}"
                class="${this.feedback ? this.feedback.type : ''}"
                placeholder="${placeholder}"
                ${this.isAnswered ? 'disabled' : ''}
              />
              <div class="hint-text">💡 输入完成后按回车键提交</div>
            </div>

            <div class="button-group">
              <button class="btn-primary" id="checkAnswerBtn">
                ${this.isAnswered ? '下一题 →' : '检查答案'}
              </button>
              ${!this.isAnswered ? `
                <button class="btn-secondary btn-small" id="skipBtn">不会</button>
              ` : ''}
            </div>
            
            <button class="btn-secondary" id="backToModeBtn" style="width: 100%; margin-top: 15px;">
              ← 返回选择模式
            </button>
          </div>
        `;
      }

      renderComplete() {
        if (!this.finalStats) {
          return '<div class="loading">加载中...</div>';
        }

        return `
          <div class="complete-container">
            <div class="complete-title">🎉 练习完成！</div>

            <div class="complete-stats">
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.totalAttempts}</div>
                <div class="complete-stat-label">总作答次数</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value green">${this.finalStats.correct}</div>
                <div class="complete-stat-label">正确数</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.accuracy}%</div>
                <div class="complete-stat-label">正确率</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.totalWords}</div>
                <div class="complete-stat-label">涉及单词</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value green">${this.finalStats.masteredWords}</div>
                <div class="complete-stat-label">多模掌握</div>
              </div>
              <div class="complete-stat-card">
                <div class="complete-stat-value purple">${this.finalStats.newlyMastered}</div>
                <div class="complete-stat-label">新增熟练</div>
              </div>
            </div>

            ${this.finalStats.repeatAttempts > 0 ? `
              <div class="smart-hint" style="margin-top: 20px;">
                <div class="smart-hint-title">🔁 已自动安排错题加练</div>
                <div class="smart-hint-text">本次有 ${this.finalStats.repeatAttempts} 次因错误重新练习，系统已自动安排复习，防止重复猜答案。</div>
              </div>
            ` : ''}

            ${this.renderSmartHint()}

            ${this.renderLearningCurve()}

            <div class="button-group">
              <button class="btn-primary" id="continueBtn">🔄 返回模式选择</button>
              <button class="btn-secondary" id="backToLibraryCompleteBtn">📚 返回词库</button>
            </div>
          </div>
        `;
      }
      
      renderSmartHint() {
        const accuracy = this.finalStats.accuracy;
        const attempts = this.finalStats.totalAttempts || 0;
        const dueCount = this.getStats().due;
        let title = '💡 智能建议';
        let text = '';

        if (accuracy < 70 && attempts > 0) {
          title = '🤔 仍需努力！';
          text = `本次正确率（${accuracy}%）有点低哦。别灰心，被标记为"错误"的单词会很快再次出现，多练几次就记住了！`;
        } else if (this.finalStats.newlyMastered > 0) {
          title = '🥳 又掌握了新模式！';
          text = `有 ${this.finalStats.newlyMastered} 个单词在至少两个模式下达标，继续保持多模练习，记忆会更加牢固！`;
        } else if (dueCount > 0) {
          title = '👍 做得不错！';
          text = `你还有 <strong>${dueCount}</strong> 个单词待复习。休息一下，或点击"返回模式选择"继续挑战吧！`;
        } else if (accuracy >= 95) {
          title = '🎉 太棒了！';
          text = '你已完成所有复习，并且保持了非常高的正确率！明天再来巩固吧。';
        } else {
          title = '🙌 练习完成！';
          text = '所有到期单词都已复习完毕！去词库添加一些新单词，或者休息一下吧。';
        }

        return `
          <div class="smart-hint">
            <div class="smart-hint-title">${title}</div>
            <div class="smart-hint-text">${text}</div>
          </div>
        `;
      }

      renderLearningCurve() {
        const words = Object.values(this.sessionResults || {})
          .sort((a, b) => {
            if ((b.masteredModes || 0) !== (a.masteredModes || 0)) {
              return (b.masteredModes || 0) - (a.masteredModes || 0);
            }
            return (b.reps || 0) - (a.reps || 0);
          })
          .slice(0, 10);

        return `
          <div class="curve-chart">
            <div class="curve-title">📊 本次学习记录 (部分)</div>
            ${words.length === 0 ? `
              <div style="padding: 10px 0; color: #64748b;">暂无练习记录</div>
            ` : ''}
            ${words.map(word => {
              const difficultyLevel = this.fsrs.getDifficultyLevel(word.difficulty);
              return `
                <div class="curve-item">
                  <span class="curve-word">${word.english}</span>
                  <div class="curve-info">
                    <span class="difficulty-badge difficulty-${difficultyLevel}">
                      难度 ${word.difficulty.toFixed(1)}
                    </span>
                    <span>稳定性: ${word.stability.toFixed(1)}天</span>
                    <span>间隔: ${word.interval}天</span>
                    <span>复习: ${word.reps}次</span>
                    <span>掌握模式: ${word.masteredModes || 0}/${MODE_IDS.length}</span>
                  </div>
                  ${this.renderModeBadges(word)}
                </div>
              `;
            }).join('')}
          </div>
        `;
      }

      attachEventListeners() {
        this.bindEvent('addWordsBtn', 'click', () => {
          const input = document.getElementById('wordInput');
          this.addWords(input.value);
        });

        this.bindEvent('startPracticeBtn', 'click', () => this.startPractice());
        this.bindEvent('quickStartNew', 'click', () => this.startQuickPractice('new'));
        this.bindEvent('quickStartStarred', 'click', () => this.startQuickPractice('starred'));
        this.bindEvent('exportBtn', 'click', () => this.exportLibrary());
        this.bindEvent('importBtn', 'click', () => this.importLibrary());
        this.bindEvent('clearBtn', 'click', () => this.clearLibrary());

        this.setupSearchInput();
        
        this.bindEvent('startConfiguredPracticeBtn', 'click', () => this.startConfiguredPractice());
        this.bindEvent('backToLibraryBtn', 'click', () => {
          this.stage = 'library';
          this.render();
        });
        this.bindEvent('quantitySlider', 'input', (e) => this.updateQuantity(e.target.value));

        document.querySelectorAll('.mode-card').forEach(card => {
          card.onclick = () => this.selectMode(parseInt(card.dataset.mode));
        });
        
        this.bindEvent('backToSettingsBtn', 'click', () => {
          this.stage = 'settings';
          this.render();
        });

        const answerInput = document.getElementById('answerInput');
        if (answerInput) {
          answerInput.oninput = (e) => {
            this.answer = e.target.value;
          };
          answerInput.onkeydown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              this.checkAnswer();
            }
          };
        }

        this.bindEvent('playAudioBtn', 'click', () => this.playAudio());
        this.bindEvent('checkAnswerBtn', 'click', () => this.checkAnswer());
        this.bindEvent('skipBtn', 'click', () => this.skipQuestion());
        this.bindEvent('backToModeBtn', 'click', () => {
          if (confirm('确定要退出当前练习吗？进度将不会保存。')) {
            this.stage = 'mode';
            this.render();
          }
        });

        this.bindEvent('continueBtn', 'click', () => {
          this.refreshSelectedWordsFromLibrary();
          this.stage = 'mode';
          this.render();
        });
        this.bindEvent('backToLibraryCompleteBtn', 'click', () => {
          this.stage = 'library';
          this.render();
        });
      }

      setupSearchInput(shouldFocus = false) {
        const searchInput = document.getElementById('searchInput');
        if (!searchInput) return;

        searchInput.value = this.searchTerm;
        searchInput.oninput = this.handleSearchInput;

        if (shouldFocus) {
          const length = searchInput.value.length;
          searchInput.focus();
          searchInput.setSelectionRange(length, length);
        }
      }

      handleSearchInput(event) {
        this.updateSearchTerm(event.target.value);
      }

      updateSearchTerm(value) {
        this.searchTerm = (value || '').toLowerCase();
        this.refreshWordList();
      }

      refreshWordList() {
        if (this.stage !== 'library') return;

        const section = document.getElementById('wordListSection');
        if (!section) return;

        const list = section.querySelector('.word-list');
        const scrollTop = list ? list.scrollTop : 0;

        section.outerHTML = this.renderWordList();
        const newSection = document.getElementById('wordListSection');
        this.setupSearchInput(true);

        if (newSection) {
          const newList = newSection.querySelector('.word-list');
          if (newList) {
            newList.scrollTop = scrollTop;
          }
        }
      }

      refreshSelectedWordsFromLibrary() {
        if (!Array.isArray(this.dueWords) || this.dueWords.length === 0) return;
        this.dueWords = this.dueWords.map(word => {
          const latest = this.library.find(item => item.english === word.english);
          return latest || word;
        });
      }

      bindEvent(id, eventType, handler) {
        const element = document.getElementById(id);
        if (element) {
          element['on' + eventType] = handler;
        }
      }
    }

    let app;
    window.addEventListener('DOMContentLoaded', () => {
      app = new VocabularyApp();
      window.app = app;
    });
  </script>
</body>
</html>